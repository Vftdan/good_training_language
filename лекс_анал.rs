/// Лексический Анализатор, а не то, что вы подумали...

use super::язык::*;
use std::fmt::Write;

pub const ПРИСТАВКИ_ПРЕПИНАНИЙ: &[&[char]] = &[
    &['('],
    &[')'],
    &[';'],
    &[','],
    &['+'],
    &[':', '='],
];

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ВидЛексемы {
    Конец,
    Идент,
    Преп,
    Число,
    Строка,
    НезавершённаяСтрока,
    Неизвестная,
}

impl ВидЛексемы {
    pub fn сущ(&self) -> Сущ {
        match self {
            ВидЛексемы::Конец => Сущ{текст: "конец ввода", род: Род::Муж},
            ВидЛексемы::Идент => Сущ{текст: "идентификатор", род: Род::Муж},
            ВидЛексемы::Преп => Сущ{текст: "знак препинания", род: Род::Муж},
            ВидЛексемы::Число => Сущ{текст: "число", род: Род::Сред},
            ВидЛексемы::Строка => Сущ{текст: "строка", род: Род::Жен},
            ВидЛексемы::НезавершённаяСтрока => Сущ{текст: "незавершённая строка", род: Род::Жен},
            ВидЛексемы::Неизвестная => Сущ{текст: "неизвестная лексема", род: Род::Жен},
        }
    }
}

// Локация - место нахождения лексемы.
#[derive(Debug, Clone)]
pub struct Лок {
    pub путь_к_файлу: String,
    pub строка: usize,
    pub столбец: usize,
}

macro_rules! диагностика {
    ($лок:expr, $уровень:literal, $формат:expr) => {
        let Лок{путь_к_файлу, строка, столбец} = $loc;
        let уровень = $уровень;
        eprint!("{путь_к_файлу}:{строка}:{столбец}: {уровень}: ", );
        eprintln!($формат)
    };
    ($лок:expr, $уровень:literal, $формат:expr, $($аргы:tt)*) => {
        let Лок{путь_к_файлу, строка, столбец} = $лок;
        let уровень = $уровень;
        eprint!("{путь_к_файлу}:{строка}:{столбец}: {уровень}: ", );
        eprintln!($формат, $($аргы)*)
    };
}

#[derive(Debug, Clone)]
pub struct Лексема {
    pub вид: ВидЛексемы,
    pub текст: String,
    pub лок: Лок,
}

pub struct ЛексАнал<'a> {
    pub символы: &'a [char],
    pub путь_к_файлу: &'a str,
    pub позиция: usize,
    pub начало_строки: usize,
    pub строка: usize,
    pub глазок: Option<Лексема>, // через, который можно лексему подсматривать
}

impl<'a> ЛексАнал<'a> {
    pub fn новый(путь_к_файлу: &'a str, символы: &'a [char]) -> ЛексАнал<'a> {
        ЛексАнал {
            символы,
            путь_к_файлу,
            позиция: 0,
            начало_строки: 0,
            строка: 0,
            глазок: None,
        }
    }

    pub fn текущий_символ(&self) -> Option<&char> {
        self.символы.get(self.позиция)
    }

    pub fn имеет_приставку(&self, приставка: &[char]) -> bool {
        self.символы[self.позиция..].starts_with(приставка)
    }

    pub fn отрезать_символы(&mut self, mut количество: usize) {
        while количество > 0 && self.текущий_символ().is_some() {
            self.отрезать_символ();
            количество -= 1;
        }
    }

    pub fn отрезать_символ(&mut self) {
        if let Some(&символ) = self.текущий_символ() {
            self.позиция += 1;
            if символ == '\n' {
                self.начало_строки = self.позиция;
                self.строка += 1;
            }
        }
    }

    pub fn подбрить_пробелы(&mut self) {
        while self.текущий_символ().map(|сим| сим.is_whitespace()).unwrap_or(false) {
            self.отрезать_символ();
        }
    }

    fn отрезать_лексему(&mut self) -> Лексема {
        self.подбрить_пробелы();
        let лок = Лок {
            строка: self.строка + 1,
            столбец: self.позиция - self.начало_строки + 1,
            путь_к_файлу: self.путь_к_файлу.to_string(),
        };

        let сим = if let Some(сим) = self.текущий_символ().cloned() {
            сим
        } else {
            return Лексема {
                вид: ВидЛексемы::Конец,
                текст: String::new(),
                лок,
            };
        };

        if сим.is_alphabetic() {
            let начало = self.позиция;
            while self.символы.get(self.позиция).map(|сим| сим.is_alphanumeric()).unwrap_or(false) {
                self.отрезать_символ();
            }
            let текст = self.символы[начало..self.позиция].iter().collect();
            return Лексема {
                вид: ВидЛексемы::Идент,
                текст,
                лок,
            }
        }

        if сим.is_numeric() {
            let начало = self.позиция;
            while self.символы.get(self.позиция).map(|сим| сим.is_numeric()).unwrap_or(false) {
                self.отрезать_символ();
            }
            let текст = self.символы[начало..self.позиция].iter().collect();
            return Лексема {
                вид: ВидЛексемы::Число,
                текст,
                лок,
            }
        }

        if сим == '"' {
            self.отрезать_символ();
            let начало = self.позиция;
            while self.текущий_символ().map(|&сим| сим != '"').unwrap_or(false) {
                self.отрезать_символ();
            }
            let текст = (&self.символы[начало..self.позиция]).iter().collect();
            match self.текущий_символ() {
                Some('"') => {
                    self.отрезать_символ();
                    return Лексема {
                        вид: ВидЛексемы::Строка,
                        текст,
                        лок,
                    };
                }
                Some(_) => unreachable!(),
                None => return Лексема {
                    вид: ВидЛексемы::НезавершённаяСтрока,
                    текст,
                    лок,
                }
            }
        }

        for приставка in ПРИСТАВКИ_ПРЕПИНАНИЙ.iter() {
            if self.имеет_приставку(приставка) {
                self.отрезать_символы(приставка.len());
                let текст = приставка.iter().collect();
                return Лексема {
                    вид: ВидЛексемы::Преп,
                    текст,
                    лок,
                }
            }
        }

        self.отрезать_символ();
        Лексема {
            вид: ВидЛексемы::Неизвестная,
            текст: сим.to_string(),
            лок,
        }
    }

    pub fn _подсмотреть_лексему(&mut self) -> Лексема {
        if let Some(лексема) = &self.глазок {
            лексема.clone()
        } else {
            let лексема = self.отрезать_лексему();
            self.глазок = Some(лексема.clone());
            лексема
        }
    }

    pub fn вытащить_лексему(&mut self) -> Лексема {
        if let Some(лексема) = self.глазок.take() {
            лексема
        } else {
            self.отрезать_лексему()
        }
    }

    pub fn ожидать_виды(&mut self, ожидаемые_виды: &[ВидЛексемы]) -> Option<Лексема> {
        assert!(ожидаемые_виды.len() > 0);

        let лексема = self.вытащить_лексему();
        for ожидаемый_вид in ожидаемые_виды {
            if лексема.вид == *ожидаемый_вид {
                return Some(лексема)
            }
        }

        if ожидаемые_виды.len() == 1 {
            let ожидаемый_вид = ожидаемые_виды[0];
            диагностика!(&лексема.лок, "ОШИБКА",
                         "{ожидался} {ожидаемый_вид}, но {повстречался} {действительный_вид}",
                         ожидался           = ГЛАГОЛ_ОЖИДАЛСЯ.отобразить(&ожидаемый_вид.сущ().род),
                         ожидаемый_вид      = ожидаемый_вид.сущ().текст,
                         повстречался       = ГЛАГОЛ_ПОВСТРЕЧАЛСЯ.отобразить(&лексема.вид.сущ().род),
                         действительный_вид = лексема.вид.сущ().текст);
        } else {
            let mut список_видов = String::new();
            for (порядок, ожидаемый_вид) in ожидаемые_виды.iter().enumerate() {
                let ожидаемый_вид = ожидаемый_вид.сущ().текст;
                if порядок == 0 {
                    write!(&mut список_видов, "{ожидаемый_вид}").unwrap();
                } else {
                    write!(&mut список_видов, ", либо {ожидаемый_вид}").unwrap();
                }
            }
            диагностика!(&лексема.лок, "ОШИБКА",
                         "ожидались {список_видов}, но {повстречался} {действительный_вид}",
                         повстречался       = ГЛАГОЛ_ПОВСТРЕЧАЛСЯ.отобразить(&лексема.вид.сущ().род),
                         действительный_вид = лексема.вид.сущ().текст);
        }

        None
    }

    pub fn ожидать_идент(&mut self, ожидаемый_текст: &str) -> Option<Лексема> {
        let идент = self.ожидать_виды(&[ВидЛексемы::Идент])?;
        if идент.текст == ожидаемый_текст {
            Some(идент)
        } else {
            диагностика!(&идент.лок, "ОШИБКА",
                         "{ожидался} `{ожидаемый_текст}`, но {повстречался} `{действительный_текст}`",
                         ожидался = ГЛАГОЛ_ОЖИДАЛСЯ.отобразить(&Род::Муж),
                         повстречался = ГЛАГОЛ_ПОВСТРЕЧАЛСЯ.отобразить(&Род::Муж),
                         действительный_текст = идент.текст);
            None
        }
    }

    pub fn ожидать_преп(&mut self, ожидаемый_текст: &str) -> Option<Лексема> {
        let преп = self.ожидать_виды(&[ВидЛексемы::Преп])?;
        if преп.текст == ожидаемый_текст {
            Some(преп)
        } else {
            диагностика!(&преп.лок, "ОШИБКА",
                         "{ожидался} `{ожидаемый_текст}`, но {повстречался} `{действительный_текст}`",
                         ожидался = ГЛАГОЛ_ОЖИДАЛСЯ.отобразить(&Род::Муж),
                         повстречался = ГЛАГОЛ_ПОВСТРЕЧАЛСЯ.отобразить(&Род::Муж),
                         действительный_текст = преп.текст);
            None
        }
    }
}

impl<'a> Iterator for ЛексАнал<'a> {
    type Item = Лексема;
    fn next(&mut self) -> Option<Self::Item> {
        let лексема = self.вытащить_лексему();
        if лексема.вид != ВидЛексемы::Конец {
            Some(лексема)
        } else {
            None
        }
    }
}
