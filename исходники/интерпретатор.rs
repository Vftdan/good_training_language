use std::io;
use std::io::Write;
use std::convert::TryInto;
use super::Результат;
use компилятор::{ПП, Инструкция};
use синтаксис::{Тип};

fn проверить_арность_аргументов(аргументы: &Vec<usize>, арность: usize, индекс_инструкции: usize, инструкция: &Инструкция) -> Результат<()> {
    if аргументы.len() < арность {
        eprintln!("{индекс_инструкции}: {инструкция:?}: ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: недостаточно аргументов для инструкции. Требуется как минимум {арность}, но всего в стеке аргументов находится {действительность}", действительность = аргументы.len());
        Err(())
    } else {
        Ok(())
    }
}

fn проверить_арность_локальных(локальные: &Vec<usize>, арность: usize, индекс_инструкции: usize, инструкция: &Инструкция) -> Результат<()> {
    if локальные.len() < арность {
        eprintln!("{индекс_инструкции}: {инструкция:?}: ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: недостаточно локальных для инструкции. Требуется как минимум {арность}, но всего в стеке локальных находится {действительность}", действительность = локальные.len());
        Err(())
    } else {
        Ok(())
    }
}

fn проверить_адрес(данные: &Vec<u8>, указатель: usize, индекс_инструкции: usize, инструкция: &Инструкция) -> Результат<()> {
    if указатель >= данные.len() {
        eprintln!("{индекс_инструкции}: {инструкция:?}: ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: инструкция попыталась получить доступ к некорректному адресу данных {указатель}. Максимально возможный {макс}.", макс = данные.len());
        return Err(())
    } else {
        Ok(())
    }
}

pub fn интерпретировать(пп: &ПП, точка_входа: usize) -> Результат<()> {
    let mut индекс_инструкции = точка_входа;
    let mut аргументы: Vec<usize> = Vec::new();
    let mut данные = пп.инициализированные_данные.clone();
    let mut локальные: Vec<usize> = Vec::new();
    let mut точки_возврата: Vec<usize> = Vec::new();

    loop {
        let инструкция = match пп.код.get(индекс_инструкции) {
            Some(инструкция) => инструкция,
            None => {
                eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный индекс инструкции {индекс_инструкции}");
                return Err(());
            }
        };

        match инструкция {
            Инструкция::Ноп => {
                индекс_инструкции += 1;
            }
            Инструкция::ПротолкнутьЦелое(значение) => {
                аргументы.push(*значение);
                индекс_инструкции += 1;
            }
            Инструкция::ПротолкнутьУказатель(указатель) => {
                // ЗАМЕЧАНИЕ: Т.к. во время интерпретации, адреса
                // данных начинаются с нуля, реализация
                // ПротолкнутьУказатель ни чем не отличается от
                // ПротолкнутьЦелое.
                аргументы.push(*указатель);
                индекс_инструкции += 1;
            }
            Инструкция::ОпределитьЛокальный => {
                проверить_арность_аргументов(&аргументы, 1, индекс_инструкции, &инструкция)?;
                локальные.push(аргументы.pop().unwrap());
                индекс_инструкции += 1;
            }
            Инструкция::СброситьЛокальный => {
                проверить_арность_локальных(&локальные, 1, индекс_инструкции, &инструкция)?;
                локальные.pop();
                индекс_инструкции += 1;
            },
            &Инструкция::ВызватьПроцедуру(точка_входа) => {
                точки_возврата.push(индекс_инструкции + 1);
                индекс_инструкции = точка_входа;
            }
            Инструкция::Записать64 => {
                проверить_арность_аргументов(&аргументы, 2, индекс_инструкции, &инструкция)?;
                let указатель = аргументы.pop().unwrap();
                let значение = аргументы.pop().unwrap();
                проверить_адрес(&данные, указатель, индекс_инструкции, &инструкция)?;
                проверить_адрес(&данные, указатель+Тип::Цел.размер() - 1, индекс_инструкции, &инструкция)?;
                данные[указатель..указатель+Тип::Цел.размер()].copy_from_slice(&значение.to_le_bytes());
                индекс_инструкции += 1;
            }
            Инструкция::Прочитать64 => {
                проверить_арность_аргументов(&аргументы, 1, индекс_инструкции, &инструкция)?;
                let указатель = аргументы.pop().unwrap();
                проверить_адрес(&данные, указатель, индекс_инструкции, &инструкция)?;
                проверить_адрес(&данные, указатель+Тип::Цел.размер() - 1, индекс_инструкции, &инструкция)?;
                аргументы.push(usize::from_le_bytes(данные[указатель..указатель+Тип::Цел.размер()].try_into().unwrap()));
                индекс_инструкции += 1;
            }
            Инструкция::ЦелМеньше => {
                проверить_арность_аргументов(&аргументы, 2, индекс_инструкции, &инструкция)?;
                let правый = аргументы.pop().unwrap();
                let левый = аргументы.pop().unwrap();
                if левый < правый {
                    аргументы.push(1)
                } else {
                    аргументы.push(0)
                }
                индекс_инструкции += 1;
            }
            Инструкция::ЦелСложение => {
                проверить_арность_аргументов(&аргументы, 2, индекс_инструкции, &инструкция)?;
                let правый = аргументы.pop().unwrap();
                let левый = аргументы.pop().unwrap();
                аргументы.push(левый + правый);
                индекс_инструкции += 1;
            }
            Инструкция::ЛогОтрицание => {
                проверить_арность_аргументов(&аргументы, 1, индекс_инструкции, &инструкция)?;
                let значение = аргументы.pop().unwrap();
                if значение == 0 {
                    аргументы.push(1);
                } else {
                    аргументы.push(0)
                }
                индекс_инструкции += 1;
            }
            Инструкция::Прыжок(адрес) => {
                индекс_инструкции = *адрес;
            }
            Инструкция::УсловныйПрыжок(адрес) => {
                проверить_арность_аргументов(&аргументы, 1, индекс_инструкции, &инструкция)?;
                let значение = аргументы.pop().unwrap();
                if значение == 0 {
                    индекс_инструкции += 1;
                } else {
                    индекс_инструкции = *адрес;
                }
            }
            Инструкция::ПечатьСтроки => {
                проверить_арность_аргументов(&аргументы, 2, индекс_инструкции, &инструкция)?;
                let указатель = аргументы.pop().unwrap();
                let длинна = аргументы.pop().unwrap();

                проверить_адрес(&данные, указатель, индекс_инструкции, &инструкция)?;
                if длинна > 0 {
                    проверить_адрес(&данные, указатель + длинна - 1, индекс_инструкции, &инструкция)?;
                }
                let _ = io::stdout().write(&данные[указатель..указатель + длинна]);

                индекс_инструкции += 1;
            }
            Инструкция::ПечатьЦелого => {
                проверить_арность_аргументов(&аргументы, 1, индекс_инструкции, &инструкция)?;
                let значение = аргументы.pop().unwrap();
                let _ = io::stdout().write(значение.to_string().as_bytes());
                индекс_инструкции += 1;
            }
            Инструкция::ПечатьЛогического => todo!("СДЕЛАТЬ: Интерпретация инструкции ПечатьЛогического"),
            Инструкция::Возврат => {
                if let Some(точка_возврата) = точки_возврата.pop() {
                    индекс_инструкции = точка_возврата;
                } else {
                    break;
                }
            },
        }
    }
    Ok(())
}
