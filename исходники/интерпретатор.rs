use std::io;
use std::io::Write;
use std::convert::TryInto;
use super::Результат;
use пп::{Программа, Инструкция};
use синтаксис::{Тип};

fn проверить_арность(стек: &Vec<usize>, арность: usize, индекс_инструкции: usize, инструкция: &Инструкция) -> Результат<()> {
    if стек.len() < арность {
        eprintln!("{индекс_инструкции}: {инструкция:?}: ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: недостаточно аргументов для инструкции. Требуется как минимум {арность}, но всего в стеке находится {действительность}", действительность = стек.len());
        Err(())
    } else {
        Ok(())
    }
}

fn проверить_адрес(данные: &Vec<u8>, указатель: usize, индекс_инструкции: usize, инструкция: &Инструкция) -> Результат<()> {
    if указатель >= данные.len() {
        eprintln!("{индекс_инструкции}: {инструкция:?}: ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: инструкция попыталась получить доступ к некорректному адресу данных {указатель}. Максимально возможный {макс}.", макс = данные.len());
        return Err(())
    } else {
        Ok(())
    }
}

pub fn интерпретировать(программа: &Программа, процедура_точки_входа: &str) -> Результат<()> {
    let mut индекс_инструкции = match программа.скомпилированные_процедуры.get(процедура_точки_входа) {
        Some(процедура) => процедура.точка_входа,
        None => {
            eprintln!("ОШИБКА: процедура точка входа «{процедура_точки_входа}» не найдена! Пожалуйста определите её!");
            return Err(());
        }
    };

    let mut стек: Vec<usize> = Vec::new();
    let mut данные = программа.данные.clone();

    loop {
        let инструкция = match программа.код.get(индекс_инструкции) {
            Some(инструкция) => инструкция,
            None => {
                eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный индекс инструкции {индекс_инструкции}");
                return Err(());
            }
        };

        match инструкция {
            Инструкция::Ноп => {
                индекс_инструкции += 1;
            }
            Инструкция::ПротолкнутьЦелое(значение) => {
                стек.push(*значение);
                индекс_инструкции += 1;
            }
            Инструкция::ПротолкнутьУказатель(указатель) => {
                // ЗАМЕЧАНИЕ: Т.к. во время интерпретации, адреса
                // данных начинаются с нуля, реализация
                // ПротолкнутьУказатель ни чем не отличается от
                // ПротолкнутьЦелое.
                стек.push(*указатель);
                индекс_инструкции += 1;
            }
            Инструкция::Записать64 => {
                проверить_арность(&стек, 2, индекс_инструкции, &инструкция)?;
                let указатель = стек.pop().unwrap();
                let значение = стек.pop().unwrap();
                проверить_адрес(&данные, указатель, индекс_инструкции, &инструкция)?;
                проверить_адрес(&данные, указатель+Тип::Цел.размер() - 1, индекс_инструкции, &инструкция)?;
                данные[указатель..указатель+Тип::Цел.размер()].copy_from_slice(&значение.to_le_bytes());
                индекс_инструкции += 1;
            }
            Инструкция::Прочитать64 => {
                проверить_арность(&стек, 1, индекс_инструкции, &инструкция)?;
                let указатель = стек.pop().unwrap();
                проверить_адрес(&данные, указатель, индекс_инструкции, &инструкция)?;
                проверить_адрес(&данные, указатель+Тип::Цел.размер() - 1, индекс_инструкции, &инструкция)?;
                стек.push(usize::from_le_bytes(данные[указатель..указатель+Тип::Цел.размер()].try_into().unwrap()));
                индекс_инструкции += 1;
            }
            Инструкция::ЦелМеньше => {
                проверить_арность(&стек, 2, индекс_инструкции, &инструкция)?;
                let правый = стек.pop().unwrap();
                let левый = стек.pop().unwrap();
                if левый < правый {
                    стек.push(1)
                } else {
                    стек.push(0)
                }
                индекс_инструкции += 1;
            }
            Инструкция::ЦелСложение => {
                проверить_арность(&стек, 2, индекс_инструкции, &инструкция)?;
                let правый = стек.pop().unwrap();
                let левый = стек.pop().unwrap();
                стек.push(левый + правый);
                индекс_инструкции += 1;
            }
            Инструкция::ЛогОтрицание => {
                проверить_арность(&стек, 1, индекс_инструкции, &инструкция)?;
                let значение = стек.pop().unwrap();
                if значение == 0 {
                    стек.push(1);
                } else {
                    стек.push(0)
                }
                индекс_инструкции += 1;
            }
            Инструкция::Прыжок(адрес) => {
                индекс_инструкции = *адрес;
            }
            Инструкция::УсловныйПрыжок(адрес) => {
                проверить_арность(&стек, 1, индекс_инструкции, &инструкция)?;
                let значение = стек.pop().unwrap();
                if значение == 0 {
                    индекс_инструкции += 1;
                } else {
                    индекс_инструкции = *адрес;
                }
            }
            Инструкция::ПечатьСтроки => {
                проверить_арность(&стек, 2, индекс_инструкции, &инструкция)?;
                let указатель = стек.pop().unwrap();
                let длинна = стек.pop().unwrap();

                проверить_адрес(&данные, указатель, индекс_инструкции, &инструкция)?;
                if длинна > 0 {
                    проверить_адрес(&данные, указатель + длинна - 1, индекс_инструкции, &инструкция)?;
                }
                let _ = io::stdout().write(&данные[указатель..указатель + длинна]);

                индекс_инструкции += 1;
            }
            Инструкция::ПечатьЦелого => {
                проверить_арность(&стек, 1, индекс_инструкции, &инструкция)?;
                let значение = стек.pop().unwrap();
                let _ = io::stdout().write(значение.to_string().as_bytes());
                индекс_инструкции += 1;
            }
            Инструкция::ПечатьЛогического => todo!("СДЕЛАТЬ: Интерпретация инструкции ПечатьЛогического"),
            Инструкция::Возврат => break,
        }
    }
    Ok(())
}
