/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use std::path::PathBuf;
use синтаксис::*;
use диагностика::*;
use лексика::*;
use типизация::*;
use интерпретатор::РАЗМЕР_СЛОВА;

/// Инструкция промежуточного представления
#[derive(Debug, PartialEq)]
pub enum ВидИнструкции {
    Ноп,
    // СДЕЛАТЬ: инстуркция Вещественное32(i32)
    /// Протолкнуть целое значение на стек аргументов.
    Целое(usize), // СДЕЛАТЬ: по возможности, использовать u64 вместо usize для значений пп
    /// Протолкнуть указатель на глобальные данные.
    ///
    /// Эта инструкция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ГлобальныеДанные(i32),

    ВыделитьНаСтеке(u64),
    ОсвободитьСоСтека(u64),
    ВершинаСтека(i32),

    СохранитьКадр,
    ВосстановитьКадр,
    Кадр(i32),

    АргументНаСтек,
    АргументСоСтека,

    Записать8,
    Записать32,
    Записать64,
    Прочитать32,
    Прочитать64,
    СкопироватьПамять,
    ЦелСложение,
    ЦелВычитание,
    ЦелУмножение,
    ЦелДеление,
    ЦелОстаток,
    ЦелМеньше,
    ЦелБольше,
    ЦелРавно,
    КонвертЦел64Вещ32,
    КонвертВещ32Цел64,
    Вещ32Умножение,
    Вещ32Деление,
    Вещ32Сложение,
    Вещ32Меньше,
    Вещ32Больше,
    Вещ32Инверт,
    ЛогОтрицание,
    БитИли,
    БитИ,
    БитСмещениеВлево,
    БитСмещениеВправо,
    ПечатьСтроки,
    Ввод,
    Возврат,
    ВнутреннийВызов(usize),
    ВнешнийВызов{индекс: usize, арность: usize, результат: Option<Тип>},
    // СДЕЛАТЬ: инструкции изменения потока исполнения должны принимать относительное смещение.
    // Данный подход позволяет создавать легко перемещаемый код. Хотя, я не уверен, что это подойдет
    // для ВызватьВнутренююПроцедуру.
    //
    // Возможно имеет смысл пойти по пути BEAM и использовать ярлыки-инструкции. Это позволит легко
    // удалять целые инструкции на этапе оптимизации.
    Прыжок(usize),
    УсловныйПрыжок(usize),
    СисВызов{ арность: usize },
}

pub struct Инструкция {
    pub лок: Лок,
    pub вид: ВидИнструкции,
}

#[derive(Debug, Clone)]
pub struct СкомпПеременная {
    pub имя: Лексема,
    pub тип: Тип,
    pub смещение: i32,
}

#[derive(Default)]
pub struct ОбластьВидимости {
    pub переменные: HashMap<String, СкомпПеременная>,
    pub константы: HashMap<String, СкомпКонстанта>,
    pub размер_переменных_на_стеке: usize,
}

#[derive(Default)]
pub struct ЛокальныеИмена {
    pub стек_областей: Vec<ОбластьВидимости>,
}

impl ЛокальныеИмена {
    fn найти_переменную_по_имени(&self, имя: &str) -> Option<&СкомпПеременная> {
        self.стек_областей.iter().rev().find_map(|область| область.переменные.get(имя))
    }

    fn найти_константу_по_имени(&self, имя: &str) -> Option<&СкомпКонстанта> {
        self.стек_областей.iter().rev().find_map(|область| область.константы.get(имя))
    }
}

#[derive(Debug)]
pub enum ТочкаВхода {
    Внутреняя { адрес: usize },
    Внешняя { индекс: usize },
}

#[derive(Clone, Debug)]
pub struct РезультатСкомпПроцедуры {
    тип: Тип,
    смещение_от_кадра: i32,
}

#[derive(Debug)]
pub struct СкомпПроцедура {
    pub имя: Лексема,
    pub параметры: Vec<СкомпПеременная>,
    pub результат: Option<РезультатСкомпПроцедуры>,
    pub точка_входа: ТочкаВхода,
}

#[derive(Debug)]
pub struct СкомпКонстанта {
    pub имя: Лексема,
    pub значение: usize,
}

/// Промежуточное Представление
#[derive(Default)]
pub struct ПП {
    pub код: Vec<Инструкция>,
    pub иниц_данные: Vec<u8>,
    pub размер_неиниц_данных: usize,
    pub заплатки_неиниц_указателей: Vec<usize>,
    pub строки: HashMap<String, usize>,
    pub внешние_символы: HashMap<String, usize>,
    pub библиотеки: HashMap<String, usize>,
}

impl ПП {
    pub fn вывалить(&self, точка_входа: usize) {
        println!("Инструкции ({количество} {инструкций}):",
                 количество = self.код.len(),
                 инструкций = ЧИСУЩ_ИНСТРУКЦИЙ.текст(self.код.len()));
        let ширина_столбца_индекса = self.код.len().to_string().len();
        let mut начало = 0;
        while начало < self.код.len() {
            let mut конец = начало;
            while конец < self.код.len() && self.код[начало].лок == self.код[конец].лок{
                конец += 1;
            }
            let Лок{путь_к_файлу, строка, столбец} = &self.код[начало].лок;
            println!("{путь_к_файлу}:{строка}:{столбец}: ", путь_к_файлу = путь_к_файлу.display());
            for индекс in начало..конец {
                print!("    {индекс:0>ширина_столбца_индекса$}: {вид:?}", вид = self.код[индекс].вид);
                if точка_входа == индекс {
                    print!(" <- точка входа");
                }
                println!();
            }
            начало = конец;
        }
        println!();
        // СДЕЛАТЬ: Показать где находятся адреса переменных в памяти
        println!("Инициализированные данные ({размер} {байт}):",
                 размер = self.иниц_данные.len(),
                 байт = ЧИСУЩ_БАЙТ.текст(self.иниц_данные.len()));
        const ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ: usize = 16;
        for строка in 0..self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ {
            let адрес = строка*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        let остаток = self.иниц_данные.len()%ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
        if остаток > 0 {
            let адрес = self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + остаток];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        println!();
        println!("Размер неинициализированных данных:");
        println!("    {размер} {байт}",
                 размер = self.размер_неиниц_данных,
                 байт = ЧИСУЩ_БАЙТ.текст(self.размер_неиниц_данных))
    }
}

#[derive(Default)]
pub struct Имена {
    pub константы: HashMap<String, СкомпКонстанта>,
    pub процедуры: HashMap<String, СкомпПроцедура>,
    pub переменные: HashMap<String, СкомпПеременная>,
    pub структуры: HashMap<String, Структура>,
}

impl Имена {
    fn верифицировать_переопределение_имени(&self, имя: &Лексема) -> Результат<()> {
        if let Some(существующая_переменная) = self.переменные.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует переменная с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_процедура) = self.процедуры.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует процедура с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_константа) = self.константы.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует константа с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_константа.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        Ok(())
    }
}

#[derive(Default)]
pub struct Программа {
    pub пп: ПП,
    pub имена: Имена,
}

fn скомпилировать_выражение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, выражение: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    match выражение {
        Выражение::Лог(лексема, значение) => {
            if *значение {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(1), лок: лексема.лок.clone() });
            } else {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(0), лок: лексема.лок.clone() });
            }
            Ok(Тип::Лог)
        }
        Выражение::ЦелЧисло(лексема, число) => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(*число), лок: лексема.лок.clone() });
            Ok(Тип::Цел64)
        },
        Выражение::ВещЧисло(лексема, число) => {
            let число = u32::from_le_bytes(число.to_le_bytes()) as usize;
            пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(число), лок: лексема.лок.clone() });
            Ok(Тип::Вещ32)
        },
        Выражение::Строка(строка) => {
            let (указатель, длинна) = if let Some(указатель) = пп.строки.get(&строка.текст) {
                (*указатель, строка.текст.len())
            } else {
                let указатель = пп.иниц_данные.len();
                let длинна = строка.текст.len();
                пп.иниц_данные.extend(строка.текст.as_bytes());
                пп.иниц_данные.push(0); // ЗАМЕТКА: нулл-терминатор на случае если мы захотим что-то передать в сишный код
                пп.строки.insert(строка.текст.clone(), указатель);
                (указатель, длинна)
            };
            let тип = Тип::Строка;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(тип.размер(&имена.структуры) as u64), лок: строка.лок.clone() });
            *временный_размер += тип.размер(&имена.структуры);

            // СДЕЛАТЬ: несколько много инструкций для компиляции простого строкового литерала
            // Может быть имеет смысл ввести сокращения для инструкций? Что-то типа Записать64НаСтеке(i32).

            пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(длинна), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: строка.лок.clone() });

            пп.код.push(Инструкция{ вид: ВидИнструкции::ГлобальныеДанные(указатель as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: строка.лок.clone() });

            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(0), лок: строка.лок.clone() });

            Ok(тип)
        }
        Выражение::Идент(лексема) => {
            if let Some(константа) = найти_константу_по_имени(&лексема.текст, имена, Some(локальные_имена)) {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(константа.значение), лок: лексема.лок.clone() });
                return Ok(Тип::Цел64);
            }
            if let Some((переменная, локация)) = найти_переменную_по_имени(&лексема.текст, имена, текущая_процедура, локальные_имена) {
                локация.протолкнуть_смещение(пп, &лексема.лок, переменная.смещение);
                if переменная.тип.примитивный() {
                    прочитать_примитивный_тип(&лексема.лок, &mut пп.код, переменная.тип.размер(&имена.структуры))?;
                }
                return Ok(переменная.тип.clone());
            }

            диагностика!(&лексема.лок, "ОШИБКА",
                         "не существует ни констант, ни переменных с имением «{имя}»",
                         имя = &лексема.текст);
            Err(())
        }
        Выражение::Биноп {ключ, вид, левое, правое} => {
            match вид {
                ВидБинопа::Поле => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    match &**правое {
                        Выражение::Идент(имя_поля) => {
                            match &левый_тип {
                                Тип::Структура(имя_структуры) => {
                                    let структура = имена
                                        .структуры
                                        .get(имя_структуры)
                                        .expect("Существование структуры должно быть уже проверено на этапе компиляции типа");
                                    if let Some(поле) = структура.поля.get(&имя_поля.текст) {
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(поле.смещение), лок: ключ.лок.clone() });
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: ключ.лок.clone() });
                                        if поле.тип.примитивный() {
                                            прочитать_примитивный_тип(&ключ.лок, &mut пп.код, поле.тип.размер(&имена.структуры))?;
                                        }
                                        Ok(поле.тип.clone())
                                    } else {
                                        диагностика!(&ключ.лок, "ОШИБКА", "У структуры «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                        Err(())
                                    }
                                }
                                _ => {
                                    диагностика!(&ключ.лок, "ОШИБКА", "У типа «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                    Err(())
                                }
                            }
                        }
                        Выражение::Вызов{..} => {
                            сделать!(&ключ.лок, "чтение полей-массивов");
                            Err(())
                        }
                        _ => {
                            диагностика!(&правое.лок(), "ОШИБКА", "Данное выражение не может быть использовано как поле");
                            Err(())
                        }
                    }
                }
                ВидБинопа::Меньше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелМеньше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Меньше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(Тип::Лог)
                }
                ВидБинопа::Больше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Больше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(Тип::Лог)
                }
                ВидБинопа::Или => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Лог | Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитИли, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&левое.лок(), "ОШИБКА", "Операция «или» не поддерживается для типов «{тип}»", тип = левый_тип.текст());
                            return Err(())
                        }
                    }
                    Ok(левый_тип.clone())
                }
                ВидБинопа::И => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитИ, лок: ключ.лок.clone() });
                        }
                        Тип::Лог => {
                            сделать!(&левое.лок(), "Логический «и»");
                        }
                        _ => {
                            диагностика!(&левое.лок(), "ОШИБКА", "Операция «и» не поддерживается для типов «{тип}»", тип = левый_тип.текст());
                            return Err(())
                        }
                    }
                    Ok(левый_тип.clone())
                }
                ВидБинопа::Сложение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Сложение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Сложение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Вычитание => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелВычитание, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Умножение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Умножение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Перемножение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Деление => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелДеление, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Деление, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Деление для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Остаток => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелОстаток, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Равно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    if левый_тип != Тип::Цел64 {
                        сделать!(левое.лок(), "Сравнение типа «{тип}»", тип = левый_тип.текст());
                        return Err(())
                    }
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелРавно, лок: ключ.лок.clone() });
                    Ok(Тип::Лог)
                }
                ВидБинопа::Как => {
                    let значение = левое;
                    let тип = правое;
                    let тип_цели = скомпилировать_тип(тип, имена, Some(локальные_имена))?;
                    let тип_значения = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &значение, временный_размер)?;

                    if тип_значения == тип_цели {
                        return Ok(тип_цели);
                    }

                    match (&тип_значения, &тип_цели) {
                        (Тип::Цел64, Тип::Цел8) => Ok(тип_цели),
                        (Тип::Цел64, Тип::Вещ32) => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертЦел64Вещ32, лок: ключ.лок.clone() });
                            Ok(тип_цели)
                        }
                        (Тип::Вещ32, Тип::Цел64) => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Цел64, лок: ключ.лок.clone() });
                            Ok(тип_цели)
                        }
                        _ => {
                            сделать!(&ключ.лок, "Конвертация типа «{тип_значения}» в тип «{тип_цели}»",
                                     тип_значения = тип_значения.текст(),
                                     тип_цели = тип_цели.текст());
                            return Err(());
                        }
                    }
                }
                ВидБинопа::ЛевоеБитовоеСмещение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитСмещениеВлево, лок: ключ.лок.clone() });
                        }
                        _ => {
                            сделать!(левое.лок(), "Левое битовое смещение типов «{тип}»", тип = левый_тип.текст());
                            return Err(())
                        }
                    }
                    Ok(левый_тип.clone())
                }
                ВидБинопа::ПравоеБитовоеСмещение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::БитСмещениеВправо, лок: ключ.лок.clone() });
                        }
                        _ => {
                            сделать!(левое.лок(), "Правое битовое смещение типов «{тип}»", тип = левый_тип.текст());
                            return Err(())
                        }
                    }
                    Ok(левый_тип.clone())
                }
            }
        }

        Выражение::УнарныйМинус {ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &выражение, временный_размер)?;
            match тип {
                Тип::Вещ32 => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Инверт, лок: ключ.лок.clone() });
                    Ok(тип)
                }
                _ => {
                    диагностика!(&ключ.лок, "ОШИБКА", "Тип «{тип}» не может быть отрицательным", тип = тип.текст());
                    Err(())
                }
            }
        }

        Выражение::Вызов {имя, аргументы} => {
            match имя.текст.as_str() {
                // СДЕЛАТЬ: не позволять переопределять процедуру интринсиков в пользовательском коде.
                "ввод" => {
                    let [массив] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 1;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };
                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Ввод параметров");
                            return Err(())
                        }
                        if let Some((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                            if let Тип::Массив{размер, тип_элемента} = &переменная.тип {
                                if **тип_элемента != Тип::Цел8 {
                                    диагностика!(&имя.лок, "ОШИБКА", "Ввод возможет только в массива элементов «{тип_элемента}»", тип_элемента = тип_элемента.текст());
                                    return Err(())
                                }

                                // СДЕЛАТЬ: принимать срез по аналогии с ПечатьСтроки
                                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(*размер), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Ввод, лок: имя.лок.clone() });
                                return Ok(Тип::Цел64);
                            } else {
                                // СДЕЛАТЬ: было бы полезно читать ввод в срезы.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Ввод можно осуществлять только в массивы на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Ввод требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                "срез" => {
                    let [массив, начало_среза, размер_среза] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 3;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Срезы параметров");
                            return Err(())
                        }
                        if let Some((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                            if let Тип::Массив{размер: _, тип_элемента} = &переменная.тип {
                                let тип_среза = Тип::Срез {
                                    тип_элемента: тип_элемента.clone()
                                };

                                let тип_размера_среза = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &размер_среза, временный_размер)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел64, &тип_размера_среза)?;
                                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);

                                let тип_начала = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &начало_среза, временный_размер)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел64, &тип_начала)?;

                                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });

                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(тип_среза.размер(&имена.структуры) as u64), лок: имя.лок.clone() });
                                *временный_размер += тип_среза.размер(&имена.структуры);
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });

                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаСтека(0), лок: имя.лок.clone() });

                                return Ok(тип_среза);
                            } else {
                                // СДЕЛАТЬ: было бы полезно иметь срезы срезов.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Срезы возможны только для массивов на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Срез требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                "сисвызов" => {
                    if аргументы.len() == 0 {
                        сделать!(&имя.лок, "Диагностика некорректной арности «сисвызов»-ов");
                        return Err(());
                    }
                    let арность = аргументы.len() - 1;

                    for аргумент in аргументы {
                        let тип_аргумента = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, аргумент, временный_размер)?;
                        проверить_типы(&аргумент.лок(), &Тип::Цел64, &тип_аргумента)?;
                    }

                    пп.код.push(Инструкция{ вид: ВидИнструкции::СисВызов{арность}, лок: имя.лок.clone() });
                    Ok(Тип::Цел64)
                }
                "адрес" => {
                    let [срез] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 1;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    let тип_среза = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &срез, временный_размер)?;
                    match тип_среза {
                        Тип::Срез{..} | Тип::Строка => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя.лок.clone()});
                            Ok(Тип::Цел64)
                        }
                        _ => {
                            диагностика!(&срез.лок(), "ОШИБКА", "Несоответствие типов данных. Ожидался тип «строка», либо «срез», но повстречался тип «{действительный}»",
                                         действительный = тип_среза.текст());
                            Err(())
                        }
                    }
                }
                _ => {
                    if let Some(процедура) = имена.процедуры.get(&имя.текст) {
                        // СДЕЛАТЬ: дупликация кода между компиляцией вызова процедур как выражений и как утверждений.

                        let количество_аргументов = аргументы.len();
                        let количество_параметров = процедура.параметры.len();
                        if количество_аргументов != количество_параметров {
                            диагностика!(&имя.лок, "ОШИБКА",
                                         "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                         параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                         аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                            return Err(());
                        }

                        for (параметр, аргумент) in процедура.параметры.iter().zip(аргументы.iter()).rev() {
                            let тип = скомпилировать_выражение(пп, имена, процедура, локальные_имена, аргумент, временный_размер)?;
                            проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                        }
                        вызвать_процедуру(имя.лок.clone(), имена, &процедура, &mut пп.код, временный_размер)?;

                        if let Some(результат) = &процедура.результат {
                            return Ok(результат.тип.clone())
                        } else {
                            диагностика!(&имя.лок, "ОШИБКА", "Данная процедура ничего не возвращает. Её нельзя использовать как выражение. Только как утверждение.");
                            return Err(())
                        }
                    }

                    if let Some((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                        match &переменная.тип {
                            Тип::Массив{тип_элемента, ..} => {
                                let [индекс] = &аргументы[..] else {
                                    диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.len());
                                    return Err(());
                                };

                                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);

                                // СДЕЛАТЬ: проверка входа за границы массива.

                                let тип_индекса = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &индекс, временный_размер)?;
                                проверить_типы(&индекс.лок(), &Тип::Цел64, &тип_индекса)?;
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });
                                if тип_элемента.примитивный() {
                                    прочитать_примитивный_тип(&имя.лок, &mut пп.код, тип_элемента.размер(&имена.структуры))?;
                                }
                                return Ok(*тип_элемента.clone())
                            }
                            Тип::Срез{..} => {
                                сделать!(&имя.лок, "Индексация срезов");
                                return Err(())
                            }
                            _ => {
                                диагностика!(&имя.лок, "ОШИБКА", "Невозможно индексировать тип «{тип}»", тип = переменная.тип.текст());
                                return Err(())
                            }
                        }
                    }

                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестное имя «{имя}»", имя = имя.текст);
                    Err(())
                }
            }
        }

        Выражение::Отрицание{ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, выражение, временный_размер)?;
            проверить_типы(&выражение.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            Ok(Тип::Лог)
        }
    }
}

fn достать_и_проверить_процедуру_печати<'ы>(имена: &'ы Имена, имя_принтера: &str, тип: &Тип, лок: &Лок) -> Результат<&'ы СкомпПроцедура> {
    if let Some(процедура) = имена.процедуры.get(имя_принтера) {
        let арность = 1;
        let [параметр] = процедура.параметры.as_slice() else {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает {число_параметров}", число_параметров = процедура.параметры.len());
            return Err(());
        };
        if параметр.тип != *тип {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает тип «{тип}»", тип = параметр.тип.текст());
            return Err(());
        }
        if let Some(результат) = &процедура.результат {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она не должна возвращать никаких результатов", тип = тип.текст());
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она возвращает тип «{тип}»", тип = результат.тип.текст());
            return Err(());
        }

        Ok(процедура)
    } else {
        диагностика!(лок, "ОШИБКА", "Чтобы печатать значения типа «{тип}», нужно чтобы где-нибудь была определена процедура с именем «{имя_принтера}», которая принимает один аргумент типа «{тип}» и печатает его. Мы не смогли найти определение такой процедуры. Обычно все нужные процедуры печати определены в модуле «прелюдия». Возможно мы не смогли его загрузить.", тип = тип.текст());
        Err(())
    }
}

fn вызвать_процедуру(лок: Лок, имена: &Имена, процедура: &СкомпПроцедура, код: &mut Vec<Инструкция>, временный_размер: &mut usize) -> Результат<()> {
    match &процедура.точка_входа {
        &ТочкаВхода::Внутреняя{адрес} => {
            код.push(Инструкция {
                вид: ВидИнструкции::ВнутреннийВызов(адрес),
                лок: лок.clone(),
            });
            if let Some(результат) = &процедура.результат {
                if !результат.тип.примитивный() {
                    *временный_размер += результат.тип.размер(&имена.структуры);
                }
            }
        },
        &ТочкаВхода::Внешняя{индекс} => {
            for параметр in &процедура.параметры {
                if параметр.тип != Тип::Цел64 {
                    сделать!(&лок, "Вызов внешней процедуры с параметрами типа «{тип}»", тип = параметр.тип.текст());
                    return Err(())
                }
            }

            код.push(Инструкция {
                вид: ВидИнструкции::ВнешнийВызов{
                    индекс,
                    арность: процедура.параметры.len(),
                    результат: процедура.результат.clone().map(|результат| результат.тип),
                },
                лок,
            });
        },
    }
    Ok(())
}

fn индексировать_массив(лок: &Лок, переменная: &СкомпПеременная, пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, индекс: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    let тип_элемента = if let Тип::Массив{тип_элемента, размер: _} = переменная.тип.clone() {
        тип_элемента
    } else {
        диагностика!(лок, "ОШИБКА", "Переменная с именем «{имя}» не является массивом. Её нельзя индексировать.", имя = переменная.имя.текст);
        return Err(());
    };

    // СДЕЛАТЬ: проверку входа за границы массива.

    let тип_индекса = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;

    проверить_типы(&индекс.лок(), &Тип::Цел64, &тип_индекса)?;
    пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(тип_элемента.размер(&имена.структуры)), лок: индекс.лок().clone() });
    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: индекс.лок().clone() });
    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: индекс.лок().clone() });

    Ok(*тип_элемента.clone())
}

enum Локация {
    Глобальная,
    Стековая,
}

impl Локация {
    fn протолкнуть_смещение(&self, пп: &mut ПП, лок: &Лок, смещение: i32) {
        match self {
            Локация::Глобальная => {
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::ГлобальныеДанные(смещение), лок: лок.clone() });
            }
            Локация::Стековая => {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(смещение), лок: лок.clone() });
            }
        }
    }
}

fn найти_константу_по_имени<'ы>(имя: &str, имена: &'ы Имена, локальные_имена: Option<&'ы ЛокальныеИмена>) -> Option<&'ы СкомпКонстанта> {
    if let Some(локальные_имена) = локальные_имена {
        if let Some(константа) = локальные_имена.найти_константу_по_имени(имя) {
            return Some(константа);
        }
    }

    if let Some(константа) = имена.константы.get(имя) {
        return Some(константа);
    }

    None
}

fn найти_переменную_по_имени<'ы>(имя: &str, имена: &'ы Имена, текущая_процедура: &'ы СкомпПроцедура, локальные_имена: &'ы ЛокальныеИмена) -> Option<(&'ы СкомпПеременная, Локация)> {
    if let Some(переменная) = локальные_имена.найти_переменную_по_имени(имя) {
        return Some((переменная, Локация::Стековая));
    }

    if let Some(параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя) {
        return Some((параметр, Локация::Стековая));
    }

    if let Some(переменная) = имена.переменные.get(имя) {
        return Some((переменная, Локация::Глобальная));
    }

    None
}

/// Левое выражение - это выражение по левой стороне от присваивания:
///
/// <левое> := <правое>;
///
/// Особенность левых выражений в том, что они являются ссылками.
fn скомпилировать_левое_выражение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &ЛокальныеИмена, выражение: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    match выражение {
        Выражение::Лог(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Логическое выражение не может находиться в левой части присваивания");
            Err(())
        }
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не может находиться в левой части присваивания");
            Err(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не может находиться в левой части присваивания");
            Err(())
        }
        Выражение::Строка(лексема) => {
            // А мы точно хотим разрешать подобные вещи?
            сделать!(&лексема.лок, "Присваивание строковых литералов");
            Err(())
        }
        Выражение::Идент(имя) => {
            if let Some((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                return Ok(переменная.тип.clone());
            }

            диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = имя.текст);
            Err(())
        }
        Выражение::Вызов{имя, аргументы} => {
            if аргументы.len() != 1 {
                диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.len());
                return Err(());
            };
            let индекс = &аргументы[0];

            if let Some((переменная, локация)) = найти_переменную_по_имени(&имя.текст, имена, текущая_процедура, локальные_имена) {
                локация.протолкнуть_смещение(пп, &имя.лок, переменная.смещение);
                let тип_элемента = индексировать_массив(&имя.лок, переменная, пп, имена, текущая_процедура, локальные_имена, индекс, временный_размер)?;
                return Ok(тип_элемента);
            }

            // СДЕЛАТЬ: Капитализировать все сообщения диагностики и заверщить их точкой в конце.
            диагностика!(&имя.лок, "ОШИБКА", "Переменной с именем «{имя}» не существует.", имя = имя.текст);
            Err(())
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Унарный минус не может находится в левой части присваивания");
            Err(())
        }
        Выражение::Биноп{ключ, вид, левое, правое} => {
            if let ВидБинопа::Поле = вид {
                let левый_тип = скомпилировать_левое_выражение(пп, имена, текущая_процедура, локальные_имена, &левое, временный_размер)?;
                match &**правое {
                    Выражение::Идент(имя_поля) => {
                        match &левый_тип {
                            Тип::Структура(имя_структуры) => {
                                let структура = имена
                                    .структуры
                                    .get(имя_структуры)
                                    .expect("Существование структуры должно быть уже проверено на этапе компиляции типа");
                                if let Some(поле) = структура.поля.get(&имя_поля.текст) {
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(поле.смещение), лок: ключ.лок.clone() });
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: ключ.лок.clone() });
                                    Ok(поле.тип.clone())
                                } else {
                                    диагностика!(&ключ.лок, "ОШИБКА", "У структуры «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                    Err(())
                                }
                            }
                            _ => {
                                диагностика!(&ключ.лок, "ОШИБКА", "У типа «{тип}» отстутствует поле «{поле}»", тип = левый_тип.текст(), поле = имя_поля.текст);
                                Err(())
                            }
                        }
                    }
                    Выражение::Вызов{..} => {
                        сделать!(&ключ.лок, "чтение полей-массивов в левой части присваивания");
                        Err(())
                    }
                    _ => {
                        диагностика!(&правое.лок(), "ОШИБКА", "Данное выражение не может быть использовано как поле");
                        Err(())
                    }
                }
            } else {
                диагностика!(&ключ.лок, "ОШИБКА", "Данная бинарная операция не может находиться в левой части присваивния");
                Err(())
            }
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не может находится в левой части присваивния");
            Err(())
        }
    }
}

fn записать_тип(лок: &Лок, код: &mut Vec<Инструкция>, структуры: &HashMap<String, Структура>, тип: &Тип) -> Результат<()> {
    if тип.примитивный() {
        записать_примитивный_тип(лок, код, тип.размер(структуры))?;
    } else {
        код.push(Инструкция{ вид: ВидИнструкции::Целое(тип.размер(структуры)), лок: лок.clone() });
        код.push(Инструкция{ вид: ВидИнструкции::СкопироватьПамять, лок: лок.clone() });
    }
    Ok(())
}

fn скомпилировать_утверждение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, локальные_имена: &mut ЛокальныеИмена, утверждение: &Утверждение, отложенные_возвраты: &mut Vec<usize>) -> Результат<()> {
    match утверждение {
        Утверждение::Присваивание{ключ, левое, правое} => {
            let mut временный_размер = 0;
            let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, правое, &mut временный_размер)?;
            let левый_тип = скомпилировать_левое_выражение(пп, имена, текущая_процедура, локальные_имена, левое, &mut временный_размер)?;
            проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
            записать_тип(&ключ.лок, &mut пп.код, &имена.структуры, &левый_тип)?;
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() })
            }
            Ok(())
        }
        Утверждение::Выражение{выражение} => {
            match выражение {
                Выражение::Вызов{имя, аргументы} => {
                    match имя.текст.as_str() {
                        // СДЕЛАТЬ: не позволять переопределять процедуру «печать» в пользовательском коде.
                        "печать" => {
                            let mut временный_размер = 0;
                            for арг in аргументы {
                                let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &арг, &mut временный_размер)?;
                                match тип {
                                    Тип::Строка => {
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: арг.лок().clone() })
                                    }
                                    Тип::Цел64 => {
                                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_цел", &тип, &арг.лок())?;
                                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                                    }
                                    Тип::Лог => {
                                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_лог", &тип, &арг.лок())?;
                                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                                    }
                                    Тип::Срез{тип_элемента} => {
                                        if *тип_элемента != Тип::Цел8 {
                                            сделать!(арг.лок(), "Печать срезов элементов типа «{тип}» пока не поддерживается",
                                                     тип = тип_элемента.текст());
                                            return Err(())
                                        }
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: имя.лок.clone() });
                                    }
                                    _ => {
                                        сделать!(арг.лок(), "печать переменных типа «{тип}»", тип = тип.текст());
                                        return Err(())
                                    }
                                }
                            }
                            if временный_размер > 0 {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: имя.лок.clone() });
                            }
                            Ok(())
                        },
                        _ => {
                            if let Some(вызываемая_процедура) = имена.процедуры.get(&имя.текст) {
                                if вызываемая_процедура.результат.is_some() {
                                    сделать!(&вызываемая_процедура.имя.лок, "Вызов процедур возвращающих значение в контексте утверждения");
                                    // За ними нужно подчищать стек аргументов.
                                    return Err(())
                                }

                                let количество_аргументов = аргументы.len();
                                let количество_параметров = вызываемая_процедура.параметры.len();
                                if количество_аргументов != количество_параметров {
                                    диагностика!(&имя.лок, "ОШИБКА",
                                                 "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                                    return Err(());
                                }

                                let mut временный_размер = 0;
                                for (параметр, аргумент) in вызываемая_процедура.параметры.iter().zip(аргументы.iter()).rev() {
                                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, аргумент, &mut временный_размер)?;
                                    проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                                }
                                вызвать_процедуру(имя.лок.clone(), имена, вызываемая_процедура, &mut пп.код, &mut временный_размер)?;
                                if временный_размер > 0 {
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: имя.лок.clone() });
                                }
                                Ok(())
                            } else {
                                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                                Err(())
                            }
                        }
                    }
                }
                _ => {
                    сделать!(выражение.лок(), "Выражения в контексте утверждений");
                    Err(())
                }
            }
        }
        Утверждение::Если{ключ, условие, тело, иначе} => {
            let mut временный_размер = 0;
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &условие, &mut временный_размер)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
            }
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });

            локальные_имена.стек_областей.push(Default::default());
            for утверждение in тело.iter() {
                скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
            }
            let размер_области = локальные_имена
                .стек_областей
                .pop()
                .expect("Тело условия «если» не трогает область которую мы протолкнули")
                .размер_переменных_на_стеке;
            if размер_области > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
            }


            if иначе.len() == 0 {
                let точка_выхода = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            } else {
                let точка_конца_тела = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });

                let точка_иначе = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_иначе);

                локальные_имена.стек_областей.push(Default::default());
                for утверждение in иначе.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
                }
                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело условия «если» не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
                }

                let точка_выхода = пп.код.len();
                пп.код[точка_конца_тела].вид = ВидИнструкции::Прыжок(точка_выхода);
            }
            Ok(())
        }
        Утверждение::Вернуть{ключ, выражение} => {
            if let Some(выражение) = выражение {
                if let Some(результат) = &текущая_процедура.результат {
                    let mut временный_размер = 0;
                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &выражение, &mut временный_размер)?;
                    проверить_типы(&выражение.лок(), &результат.тип, &тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(результат.смещение_от_кадра), лок: ключ.лок.clone() });
                    записать_тип(&ключ.лок, &mut пп.код, &имена.структуры, &тип)?;
                    let размер_всех_локальных_переменных = локальные_имена
                        .стек_областей
                        .iter()
                        .map(|область| область.размер_переменных_на_стеке)
                        .sum::<usize>();
                    if временный_размер + размер_всех_локальных_переменных > 0 {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека((временный_размер + размер_всех_локальных_переменных) as u64), лок: выражение.лок().clone() });
                    }
                } else {
                    диагностика!(выражение.лок(), "ОШИБКА", "Процедура не возвращает никаких значений");
                    return Err(());
                }
            } else {
                if let Some(результат) = &текущая_процедура.результат {
                    диагностика!(&ключ.лок, "ОШИБКА", "Процедура возвращает значение типа «{тип}»", тип = результат.тип.текст());
                    return Err(());
                }
            }
            отложенные_возвраты.push(пп.код.len());
            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(0), лок: ключ.лок.clone() });
            Ok(())
        }
        Утверждение::Пока{ключ, условие, тело} => {
            let точка_условия = пп.код.len();
            let mut временный_размер = 0;
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &условие, &mut временный_размер)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
            }
            let точка_условного_прыжка = пп.код.len();

            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
            локальные_имена.стек_областей.push(Default::default());
            for утверждение in тело.iter() {
                скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
            }
            let размер_области = локальные_имена
                .стек_областей
                .pop()
                .expect("Тело цикла «пока» не трогает область которую мы протолкнули")
                .размер_переменных_на_стеке;
            if размер_области > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
            }

            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(точка_условия), лок: ключ.лок.clone() });
            let точка_выхода = пп.код.len();
            пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            Ok(())
        }
        Утверждение::Для{ключ, индекс, свой_индекс, нижняя_граница, верхняя_граница, тело} => {
            локальные_имена.стек_областей.push(Default::default());
            if *свой_индекс {
                let размер_всех_локальных_переменных = локальные_имена
                    .стек_областей
                    .iter()
                    .map(|область| область.размер_переменных_на_стеке)
                    .sum::<usize>();

                let тип_переменной = Тип::Цел64;
                let размер = выравнять_размер_по_слову(тип_переменной.размер(&имена.структуры));
                пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(размер as u64), лок: ключ.лок.clone() });
                let смещение =
                    -(2*(РАЗМЕР_СЛОВА as i32))                  // пропускаем кадр и адрес возврата
                    -(размер as i32)                            // сама переменная
                    -(размер_всех_локальных_переменных as i32); // пропускаем все предыдущие локальные переменные

                let текущая_область_видимости = локальные_имена
                    .стек_областей
                    .last_mut()
                    .expect("Компиляция процедуры обязана создать хотя бы одну область видимости");

                // СДЕЛАТЬ: Проверка затенения имен локальными переменными.
                if let Some(существующая_переменная) = текущая_область_видимости.переменные.get(&индекс.текст) {
                    диагностика!(&индекс.лок, "ОШИБКА", "Переопределение локальной переменной «{имя}»", имя = индекс.текст);
                    диагностика!(&существующая_переменная.имя.лок, "ИНФО", "Первое определение находится здесь");
                    return Err(());
                }
                текущая_область_видимости.переменные.insert(индекс.текст.clone(), СкомпПеременная {
                    имя: индекс.clone(),
                    тип: тип_переменной,
                    смещение
                });
                текущая_область_видимости.размер_переменных_на_стеке += размер;
            }
            if let Some((переменная, локация)) = найти_переменную_по_имени(&индекс.текст, имена, текущая_процедура, локальные_имена) {
                проверить_типы(&индекс.лок, &Тип::Цел64, &переменная.тип)?;

                // Инициализация индексной переменной
                let mut временный_размер = 0;
                let тип_нижней_границы = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &нижняя_граница, &mut временный_размер)?;
                проверить_типы(&нижняя_граница.лок(), &переменная.тип, &тип_нижней_границы)?;
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная.смещение);
                записать_тип(&индекс.лок, &mut пп.код, &имена.структуры, &переменная.тип)?;
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
                    временный_размер = 0;
                }

                // Проверка условия выхода из цикла
                let точка_условия = пп.код.len();
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная.смещение);
                прочитать_примитивный_тип(&индекс.лок, &mut пп.код, переменная.тип.размер(&имена.структуры))?;
                let тип_верхней_границы = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, &верхняя_граница, &mut временный_размер)?;
                проверить_типы(&верхняя_граница.лок(), &переменная.тип, &тип_верхней_границы)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольше, лок: ключ.лок.clone() });
                let точка_условного_прыжка = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
                }

                let переменная_тип = переменная.тип.clone();
                let переменная_смещение = переменная.смещение;

                // Тело
                for утверждение in тело.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, локальные_имена, утверждение, отложенные_возвраты)?;
                }

                // Инкремент
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная_смещение);
                прочитать_примитивный_тип(&индекс.лок, &mut пп.код, переменная_тип.размер(&имена.структуры))?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::Целое(1), лок: ключ.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: ключ.лок.clone() });
                локация.протолкнуть_смещение(пп, &индекс.лок, переменная_смещение);
                записать_тип(&индекс.лок, &mut пп.код, &имена.структуры, &переменная_тип)?;


                пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(точка_условия), лок: ключ.лок.clone() });
                let точка_выхода = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);

                let размер_области = локальные_имена
                    .стек_областей
                    .pop()
                    .expect("Тело цикла «для» не трогает область которую мы протолкнули")
                    .размер_переменных_на_стеке;
                if размер_области > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: ключ.лок.clone() });
                }

                return Ok(())
            }

            диагностика!(&индекс.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = индекс.текст);
            Err(())
        }
        Утверждение::ДекларацияПеременной{ключ, имя, тип, значение} => {
            let размер_всех_локальных_переменных = локальные_имена
                .стек_областей
                .iter()
                .map(|область| область.размер_переменных_на_стеке)
                .sum::<usize>();

            let тип_переменной = скомпилировать_тип(тип, имена, Some(локальные_имена))?;
            let размер = выравнять_размер_по_слову(тип_переменной.размер(&имена.структуры));
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(размер as u64), лок: ключ.лок.clone() });
            let смещение =
                -(2*(РАЗМЕР_СЛОВА as i32))                  // пропускаем кадр и адрес возврата
                -(размер as i32)                            // сама переменная
                -(размер_всех_локальных_переменных as i32); // пропускаем все предыдущие локальные переменные

            if let Some(значение) = значение {
                let mut временный_размер = 0;
                let тип_значения = скомпилировать_выражение(пп, имена, текущая_процедура, локальные_имена, значение, &mut временный_размер)?;
                проверить_типы(&значение.лок(), &тип_переменной, &тип_значения)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(смещение), лок: ключ.лок.clone() });
                записать_тип(&ключ.лок, &mut пп.код, &имена.структуры, &тип_переменной)?;
                if временный_размер > 0 {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(временный_размер as u64), лок: ключ.лок.clone() });
                }
            }

            let текущая_область_видимости = локальные_имена
                .стек_областей
                .last_mut()
                .expect("Компиляция процедуры обязана создать хотя бы одну область видимости");
            // СДЕЛАТЬ: Проверка затенения имен локальными переменными.
            if let Some(существующая_переменная) = текущая_область_видимости.переменные.get(&имя.текст) {
                диагностика!(&имя.лок, "ОШИБКА", "Переопределение локальной переменной «{имя}»", имя = имя.текст);
                диагностика!(&существующая_переменная.имя.лок, "ИНФО", "Первое определение находится здесь");
                return Err(());
            }
            текущая_область_видимости.переменные.insert(имя.текст.clone(), СкомпПеременная {
                имя: имя.clone(),
                тип: тип_переменной,
                смещение
            });
            текущая_область_видимости.размер_переменных_на_стеке += размер;

            Ok(())
        }
        Утверждение::ДекларацияКонстанты{имя, значение, ..} => {
            let значение = интерпретировать_выражение_константы(имена, Some(локальные_имена), значение)?;

            let текущая_область_видимости = локальные_имена
                .стек_областей
                .last_mut()
                .expect("Компиляция процедуры обязана создать хотя бы одну область видимости");
            // СДЕЛАТЬ: Проверка затенения имен локальными константами.
            if let Some(существующая_константа) = текущая_область_видимости.константы.get(&имя.текст) {
                диагностика!(&имя.лок, "ОШИБКА", "Переопределение локальной константы «{имя}»", имя = имя.текст);
                диагностика!(&существующая_константа.имя.лок, "ИНФО", "Первое определение находится здесь");
                return Err(());
            }

            текущая_область_видимости.константы.insert(имя.текст.clone(), СкомпКонстанта {
                имя: имя.clone(),
                значение,
            });

            Ok(())
        }
    }
}

fn выравнять_размер_по_слову(размер: usize) -> usize {
    (размер + РАЗМЕР_СЛОВА - 1)/РАЗМЕР_СЛОВА*РАЗМЕР_СЛОВА
}

fn записать_примитивный_тип(лок: &Лок, код: &mut Vec<Инструкция>, размер: usize) -> Результат<()> {
    match размер {
        1 => код.push(Инструкция{ вид: ВидИнструкции::Записать8, лок: лок.clone() }),
        2 => {
            сделать!(лок, "Запись размером в 16 бит");
            return Err(());
        }
        4 => код.push(Инструкция{ вид: ВидИнструкции::Записать32, лок: лок.clone() }),
        8 => код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: лок.clone() }),
        размер => unreachable!("Примитивных типов размера {} нет", размер),
    }
    Ok(())
}

fn прочитать_примитивный_тип(лок: &Лок, код: &mut Vec<Инструкция>, размер: usize) -> Результат<()> {
    match размер {
        1 => {
            сделать!(лок, "Чтение размером в 8 бит");
            return Err(());
        }
        2 => {
            сделать!(лок, "Чтение размером в 16 бит");
            return Err(());
        }
        4 => код.push(Инструкция{ вид: ВидИнструкции::Прочитать32, лок: лок.clone() }),
        8 => код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: лок.clone() }),
        размер => unreachable!("Примитивных типов размера {} нет", размер),
    }
    Ok(())
}


fn скомпилировать_процедуру(пп: &mut ПП, имена: &mut Имена, процедура: Процедура) -> Результат<()> {
    let mut параметры = Vec::new();
    let mut размер_параметров_на_стеке: usize = 0;

    for параметр in &процедура.параметры {
        let тип = скомпилировать_тип(&параметр.тип, имена, None)?;
        let скомп_параметр = СкомпПеременная {
            имя: параметр.имя.clone(),
            тип,
            смещение: размер_параметров_на_стеке as i32,
        };
        размер_параметров_на_стеке += выравнять_размер_по_слову(скомп_параметр.тип.размер(&имена.структуры));
        параметры.push(скомп_параметр);
    }
    let результат = if let Some(тип) = процедура.тип_результата {
        let результат = РезультатСкомпПроцедуры {
            тип: скомпилировать_тип(&тип, имена, None)?,
            смещение_от_кадра: размер_параметров_на_стеке as i32,
        };
        размер_параметров_на_стеке += выравнять_размер_по_слову(результат.тип.размер(&имена.структуры));
        Some(результат)
    } else {
        None
    };
    match процедура.тело {
        ТелоПроцедуры::Внутренее{блок} => {
            let адрес = пп.код.len();
            let скомп_процедура = СкомпПроцедура{
                имя: процедура.имя.clone(),
                параметры,
                точка_входа: ТочкаВхода::Внутреняя{адрес},
                результат,
            };

            if let Some(_) = имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }

            let скомп_процедура = имена.процедуры.get(&процедура.имя.текст).unwrap();

            // СДЕЛАТЬ: Если размер_параметров_на_стеке равен 0, то, наверное, не имеет никакого смысла вообще включать данную инструкцию
            // Тоже самое можно сказать и про противоположную инструкцию ОсвободитьСоВторогоСтека.
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаСтеке(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::СохранитьКадр, лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::АргументНаСтек, лок: процедура.имя.лок.clone() }); // сохраняем адрес возврата на второй стек
            for параметр in скомп_процедура.параметры.iter() {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(параметр.смещение), лок: параметр.имя.лок.clone() });
                записать_тип(&параметр.имя.лок, &mut пп.код, &имена.структуры, &параметр.тип)?;
            }
            let mut отложенные_возвраты = Vec::new();
            let mut локальные_имена = ЛокальныеИмена::default();
            локальные_имена.стек_областей.push(Default::default());
            for утверждение in &блок {
                скомпилировать_утверждение(пп, имена, &скомп_процедура, &mut локальные_имена, утверждение, &mut отложенные_возвраты)?;
            }
            let размер_области = локальные_имена
                .стек_областей
                .pop()
                .expect("Тело процедуры не трогает область которую мы протолкнули")
                .размер_переменных_на_стеке;
            if размер_области > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_области as u64), лок: процедура.имя.лок.clone() });
            }

            let конец_процедуры = пп.код.len();
            for адрес in отложенные_возвраты {
                let инструкция = пп.код.get_mut(адрес).expect("отложенные возвраты из процедуры: некорретный адрес");
                assert!(инструкция.вид == ВидИнструкции::Прыжок(0), "отложенные возвраты из процедуры: некорректная инструкция: {:?}", инструкция.вид);
                инструкция.вид = ВидИнструкции::Прыжок(конец_процедуры);
            }
            if let Some(результат) = &скомп_процедура.результат {
                пп.код.push(Инструкция{ вид: ВидИнструкции::Кадр(результат.смещение_от_кадра), лок: процедура.имя.лок.clone() });
                if результат.тип.примитивный() {
                    прочитать_примитивный_тип(&процедура.имя.лок, &mut пп.код, результат.тип.размер(&имена.структуры))?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
                } else {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_параметров_на_стеке as u64 - результат.тип.размер(&имена.структуры) as u64), лок: процедура.имя.лок.clone() });
                }
            } else {
                пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоСтека(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::Возврат, лок: процедура.имя.лок.clone() });
            Ok(())
        }
        ТелоПроцедуры::Внешнее{символ} => {
            let индекс = пп.внешние_символы.len();
            let индекс = *пп.внешние_символы.entry(символ.текст).or_insert(индекс);
            let скомп_процедура = СкомпПроцедура{
                имя: процедура.имя,
                параметры,
                точка_входа: ТочкаВхода::Внешняя{индекс},
                результат,
            };
            if let Some(_) = имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }
            Ok(())
        }
    }
}

fn интерпретировать_выражение_константы(имена: &Имена, локальные_имена: Option<&ЛокальныеИмена>, выражение: &Выражение) -> Результат<usize> {
    match выражение {
        &Выражение::ЦелЧисло(_, число) => Ok(число),
        Выражение::Лог(лексема, _) => {
            сделать!(&лексема.лок, "логические выражения");
            Err(())
        },
        Выражение::ВещЧисло(лексема, _) => {
            сделать!(&лексема.лок, "вещественные константы");
            Err(())
        },
        Выражение::Строка(строка) => {
            сделать!(&строка.лок, "строковые константы");
            Err(())
        }
        Выражение::Идент(имя) => {
            if let Some(константа) = найти_константу_по_имени(&имя.текст, имена, локальные_имена) {
                Ok(константа.значение)
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, вид, левое, правое, ..} => {
            let левое_значение = интерпретировать_выражение_константы(имена, локальные_имена, левое)?;
            let правое_значение = интерпретировать_выражение_константы(имена, локальные_имена, правое)?;
            match вид {
                ВидБинопа::Равно | ВидБинопа::Меньше | ВидБинопа::Больше | ВидБинопа::Или | ВидБинопа::И => {
                    сделать!(&ключ.лок, "булевые константы");
                    Err(())
                },
                ВидБинопа::Поле => {
                    сделать!(&ключ.лок, "взятие поля в константном контексте");
                    Err(())
                }
                ВидБинопа::Сложение => {
                    Ok(левое_значение + правое_значение)
                }
                ВидБинопа::Вычитание => {
                    Ok(левое_значение - правое_значение)
                }
                ВидБинопа::Умножение => {
                    Ok(левое_значение * правое_значение)
                }
                ВидБинопа::Деление => {
                    Ok(левое_значение / правое_значение)
                }
                ВидБинопа::Остаток => {
                    Ok(левое_значение % правое_значение)
                }
                ВидБинопа::ЛевоеБитовоеСмещение => {
                    Ok(левое_значение << правое_значение)
                }
                ВидБинопа::ПравоеБитовоеСмещение => {
                    Ok(левое_значение >> правое_значение)
                }
                ВидБинопа::Как => {
                    сделать!(&ключ.лок, "Мы пока что вообще не имеем типов в константах");
                    Err(())
                }
            }
        }
        Выражение::УнарныйМинус {ключ, выражение: _} => {
            сделать!(&ключ.лок, "константы пока что не могу быть отрицательными");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            сделать!(&ключ.лок, "булевые константы");
            Err(())
        }
        Выражение::Вызов{имя, ..} => {
            сделать!(&имя.лок, "вызов функции в константном контексте");
            Err(())
        }
    }
}

fn скомпилировать_тип(тип: &Выражение, имена: &Имена, локальные_имена: Option<&ЛокальныеИмена>) -> Результат<Тип> {
    match тип {
        Выражение::Лог(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Логические выражения не являться типами");
            Err(())
        }
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не является являться типом");
            Err(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не является являться типом");
            Err(())
        }
        Выражение::Строка(лексема) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Строка не является являться типом");
            Err(())
        }
        Выражение::Идент(лексема) => match лексема.текст.as_str() {
            "цел" | "цел64" => Ok(Тип::Цел64),
            "цел8" => Ok(Тип::Цел8),
            "вещ" | "вещ32" => Ok(Тип::Вещ32),
            "строка" => Ok(Тип::Строка),
            "лог" => Ok(Тип::Лог),
            _ => {
                if имена.структуры.contains_key(&лексема.текст) {
                    Ok(Тип::Структура(лексема.текст.clone()))
                } else {
                    диагностика!(&лексема.лок, "ОШИБКА", "Неизвестный тип «{тип}»", тип = лексема.текст);
                    Err(())
                }
            }
        }
        Выражение::Вызов{имя, аргументы} => match имя.текст.as_str() {
            "массив" => {
                let [размер, тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 2;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let размер = интерпретировать_выражение_константы(имена, локальные_имена, &размер)?;
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, имена, локальные_имена)?);
                Ok(Тип::Массив{размер, тип_элемента})
            }
            "срез" => {
                let [тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 1;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, имена, локальные_имена)?);
                Ok(Тип::Срез{тип_элемента})
            }
            _ => {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестный параметризированный тип «{тип}»", тип = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные бинарные операции не поддерживаются в типах");
            Err(())
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные унарные операции не поддерживаются в типах");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не поддерживается в типах");
            // Хотя, это довольно таки интересна идея. Тип «не цел». Любой тип, кроме целого...
            Err(())
        }
    }
}

impl Программа {
    pub fn скомпилировать_лексемы(&mut self, лекс: &mut Лексер) -> Результат<()> {
        loop {
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::КлючПер,
                ВидЛексемы::КлючПро,
                ВидЛексемы::КлючКонст,
                ВидЛексемы::КлючВкл,
                ВидЛексемы::КлючБибл,
                ВидЛексемы::КлючСтрукт,
                ВидЛексемы::Конец,
            ])?;
            match ключ.вид {
                ВидЛексемы::КлючПер => {
                    let синтаксис = Переменная::разобрать(лекс)?;
                    let имя = синтаксис.имя;
                    self.имена.верифицировать_переопределение_имени(&имя)?;
                    let тип = скомпилировать_тип(&синтаксис.тип, &self.имена, None)?;
                    let смещение = self.пп.размер_неиниц_данных as i32;
                    self.пп.размер_неиниц_данных += тип.размер(&self.имена.структуры);
                    if let Some(_) = self.имена.переменные.insert(имя.текст.clone(), СкомпПеременная {имя, тип, смещение}) {
                        unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючПро => {
                    let процедура = Процедура::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&процедура.имя)?;
                    скомпилировать_процедуру(&mut self.пп, &mut self.имена, процедура)?;
                }
                ВидЛексемы::КлючКонст => {
                    let константа = Константа::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&константа.имя)?;
                    let значение = интерпретировать_выражение_константы(&self.имена, None, &константа.выражение)?;
                    if let Some(_) = self.имена.константы.insert(константа.имя.текст.clone(), СкомпКонстанта {
                        имя: константа.имя.clone(),
                        значение
                    }) {
                        unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючВкл => {
                    // СДЕЛАТЬ: расхардкодить пути поиска модулей
                    let пути_поиска_модулей = &[".", "./модули"];
                    // СДЕЛАТЬ: отслеживать повторное включение модулей и игнорировать его.
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                    let mut существует = false;
                    for путь in пути_поиска_модулей {
                        let mut путь_к_файлу = PathBuf::new();
                        путь_к_файлу.push(путь);
                        путь_к_файлу.push(&имя.текст);
                        путь_к_файлу.set_extension("хуя");
                        if путь_к_файлу.exists() {
                            существует = true;
                            let содержимое = ::прочитать_содержимое_файла(&путь_к_файлу, Some(имя.лок.clone()))?;
                            let mut лекс = Лексер::новый(&путь_к_файлу, &содержимое);
                            self.скомпилировать_лексемы(&mut лекс)?;
                            break;
                        }
                    }
                    if !существует {
                        диагностика!(имя.лок, "ОШИБКА", "Не удалось найти модуль «{имя}».", имя = имя.текст);
                        return Err(());
                    }
                }
                ВидЛексемы::КлючБибл => {
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    self.пп.библиотеки.insert(имя.текст.clone(), self.пп.библиотеки.len());
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                }
                ВидЛексемы::КлючСтрукт => {
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючНч])?;
                    let mut поля: HashMap<String, Поле> = HashMap::new();
                    let mut размер = 0;
                    // СДЕЛАТЬ: однополевые структуры через ключ «то»
                    while лекс.подсмотреть_лексему()?.вид != ВидЛексемы::КлючКц {
                        let смещение = размер;
                        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Двоеточие])?;
                        let тип = скомпилировать_тип(&Выражение::разобрать(лекс)?, &self.имена, None)?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                        размер += выравнять_размер_по_слову(тип.размер(&self.имена.структуры));
                        if let Some(дубль) = поля.get(&имя.текст) {
                            диагностика!(&имя.лок, "ОШИБКА", "Поле «{имя}» уже существует", имя = имя.текст);
                            диагностика!(&дубль.имя.лок, "ИНФО", "Оно определено здесь");
                            return Err(());
                        }
                        if let Some(_) = поля.insert(имя.текст.clone(), Поле {имя, тип, смещение}) {
                            unreachable!();
                        }
                    }
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючКц])?;
                    if let Some(дубль) = self.имена.структуры.get(&имя.текст) {
                        диагностика!(&имя.лок, "ОШИБКА", "Структура «{имя}» уже существует", имя = имя.текст);
                        диагностика!(&дубль.имя.лок, "ИНФО", "Она определено здесь");
                        return Err(());
                    }
                    if let Some(_) = self.имена.структуры.insert(имя.текст.clone(), Структура {имя, поля, размер}) {
                        unreachable!()
                    }
                }
                ВидЛексемы::Конец => break,
                _ => unreachable!(),
            }
        }

        Ok(())
    }

    pub fn завершить_компиляцию(&mut self) {
        for (_, СкомпПеременная{смещение, ..}) in self.имена.переменные.iter_mut() {
            *смещение += self.пп.иниц_данные.len() as i32;
        }

        for индекс in &self.пп.заплатки_неиниц_указателей {
            if let Some(Инструкция{ вид: ВидИнструкции::ГлобальныеДанные(указатель), .. }) = self.пп.код.get_mut(*индекс) {
                *указатель += self.пп.иниц_данные.len() as i32;
            } else {
                unreachable!("Ошибка в процессе сбора заплаток указателей на неинициализированные данные. Каждый индекс такой заплатки должен указывать на инструкцию ПротолкнутьУказатель");
            }
        }
    }
}
