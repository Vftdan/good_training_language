/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use синтаксис::*;
use диагностика::*;
use лексика::*;
use типизация::*;

// СДЕЛАТЬ: трансформировать Инструкцию в структуру наподобие Лексемы, с полями «вид», «лок» и тд.

/// Инструкция промежуточного представления
#[derive(Debug)]
pub enum Инструкция {
    Ноп,
    Пометка(Лексема), // СДЕЛАТЬ: может имеет смысл ввести локацию в саму инструкцию?
    /// Протолкнуть целое значение на стек аргументов.
    ПротолкнутьЦелое(usize),
    /// Протолкнуть указатель на данные.
    ///
    /// Эта инстуркция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ПротолкнутьУказатель(usize), // СДЕЛАТЬ: по возможности, использовать u64 вместо usize для значений пп
    Вытолкнуть(usize),
    СохранитьКадр,
    ВосстановитьКадр,
    ПрочитатьКадр(usize),
    ЗаписатьКадр(usize),
    ВызватьПроцедуру(usize),
    Записать64,
    Прочитать64,
    ЦелСложение,
    ЦелВычитание,
    ЦелУмножение,
    ЦелДеление,
    ЦелОстаток,
    ЦелМеньше,
    ЦелБольше,
    ЦелРавно,
    ЛогОтрицание,
    ПечатьСтроки,
    Возврат,
    Прыжок(usize),
    УсловныйПрыжок(usize),
}

#[derive(Clone)]
pub struct СкомпПеременная {
    pub имя: Лексема,
    pub тип: Тип,
    pub адрес: usize,
}

pub struct СкомпПараметр {
    pub имя: Лексема,
    pub тип: Тип,
}

pub struct СкомпПроцедура {
    pub имя: Лексема,
    pub параметры: Vec<СкомпПараметр>,
    pub точка_входа: usize,
}

#[derive(Debug)]
pub struct СкомпКонстанта {
    pub синтаксис: Константа,
    pub значение: usize,
}

/// Промежуточное Представление
#[derive(Default)]
pub struct ПП {
    pub код: Vec<Инструкция>,
    pub иниц_данные: Vec<u8>,
    pub размер_неиниц_данных: usize,
    pub заплатки_неиниц_указателей: Vec<usize>,
}

impl ПП {
    pub fn вывалить(&self, точка_входа: usize) {
        println!("Инструкции ({количество} {инструкций}):",
                 количество = self.код.len(),
                 инструкций = ЧИСУЩ_ИНСТРУКЦИЙ.текст(self.код.len()));
        let ширина_столбца_индекса = self.код.len().to_string().len();
        for (индекс, инструкция) in self.код.iter().enumerate() {
            if let Инструкция::Пометка(лексема) = инструкция {
                let Лок{путь_к_файлу, строка, столбец} = &лексема.лок;
                let текст = &лексема.текст;
                print!("{путь_к_файлу}:{строка}:{столбец}: Пометка: ");
                if лексема.вид == ВидЛексемы::Строка {
                    print!("{текст:?}")
                } else {
                    print!("{текст}")
                }
            } else {
                print!("    {индекс:0>ширина_столбца_индекса$}: {инструкция:?}")
            }
            if точка_входа == индекс {
                print!(" <- точка входа");
            }
            println!()
        }
        println!();
        // СДЕЛАТЬ: Ввести похожее понятие пометок для инициализированных и неинициализированных данных
        println!("Инициализированные данные ({размер} {байт}):",
                 размер = self.иниц_данные.len(),
                 байт = ЧИСУЩ_БАЙТ.текст(self.иниц_данные.len()));
        const ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ: usize = 16;
        for строка in 0..self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ {
            let адрес = строка*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        let остаток = self.иниц_данные.len()%ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
        if остаток > 0 {
            let адрес = self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + остаток];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        println!();
        println!("Размер неинициализированных данных:");
        println!("    {размер} {байт}",
                 размер = self.размер_неиниц_данных,
                 байт = ЧИСУЩ_БАЙТ.текст(self.размер_неиниц_данных))
    }
}

#[derive(Default)]
pub struct Имена {
    pub константы: HashMap<String, СкомпКонстанта>,
    pub процедуры: HashMap<String, СкомпПроцедура>,
    pub переменные: HashMap<String, СкомпПеременная>,
}

impl Имена {
    fn верифицировать_переопределение_имени(&self, имя: &Лексема) -> Результат<()> {
        if let Some(существующая_переменная) = self.переменные.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует переменная с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_процедура) = self.процедуры.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует процедура с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_константа) = self.константы.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует константа с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_константа.синтаксис.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        Ok(())
    }
}

#[derive(Default)]
pub struct Программа {
    pub пп: ПП,
    pub имена: Имена,
}

fn скомпилировать_выражение(пп: &mut ПП, имена: &Имена, параметры: &Vec<СкомпПараметр>, выражение: &Выражение) -> Результат<Тип> {
    match выражение {
        Выражение::Число(лексема, число) => {
            пп.код.push(Инструкция::Пометка(лексема.clone()));
            пп.код.push(Инструкция::ПротолкнутьЦелое(*число));
            Ok(Тип::Цел8)
        },
        Выражение::Строка(строка) => {
            let указатель = пп.иниц_данные.len();
            let длинна = строка.текст.len();
            пп.иниц_данные.extend(строка.текст.as_bytes());
            пп.код.push(Инструкция::Пометка(строка.clone()));
            пп.код.push(Инструкция::ПротолкнутьЦелое(длинна));
            пп.код.push(Инструкция::ПротолкнутьУказатель(указатель));
            Ok(Тип::Строка)
        }
        Выражение::Идент(лексема) => {
            if let Some(константа) = имена.константы.get(&лексема.текст) {
                пп.код.push(Инструкция::Пометка(лексема.clone()));
                пп.код.push(Инструкция::ПротолкнутьЦелое(константа.значение));
                return Ok(Тип::Цел8);
            }
            if let Some((порядок, параметр)) = параметры.iter().enumerate().find(|(_, параметр)| параметр.имя.текст == лексема.текст) {
                if параметр.тип != Тип::Цел8 {
                    сделать!(&лексема.лок, "Чтение параметров типа «{тип}»", тип = параметр.тип.текст());
                    return Err(());
                }
                пп.код.push(Инструкция::Пометка(лексема.clone()));
                пп.код.push(Инструкция::ПрочитатьКадр(порядок));
                return Ok(параметр.тип.clone());
            }
            if let Some(переменная) = имена.переменные.get(&лексема.текст) {
                пп.код.push(Инструкция::Пометка(лексема.clone()));
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция::ПротолкнутьУказатель(переменная.адрес));
                match переменная.тип {
                    Тип::Цел1 => {
                        сделать!(&лексема.лок, "чтение {}", переменная.тип.текст());
                        return Err(())
                    }
                    Тип::Цел8 => {
                        пп.код.push(Инструкция::Прочитать64);
                        return Ok(переменная.тип.clone());
                    }
                    Тип::Лог => {
                        сделать!(&лексема.лок, "чтение логических переменных");
                        return Err(())
                    }
                    Тип::Строка => {
                        сделать!(&лексема.лок, "чтение строковых переменных");
                        return Err(())
                    }
                    Тип::Массив{..} => {
                        сделать!(&лексема.лок, "чтение массивов");
                        return Err(())
                    }
                    Тип::Срез{..} => {
                        сделать!(&лексема.лок, "чтение Срезов");
                        return Err(())
                    }
                }
            }
            диагностика!(&лексема.лок, "ОШИБКА",
                         "не существует ни констант, ни переменных с имением «{имя}»",
                         имя = &лексема.текст);
            Err(())
        }
        Выражение::Биноп {ключ, вид, левое, правое} => {
            let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
            let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
            match вид {
                ВидБинопа::Меньше => {
                    проверить_типы(левое.лок(), &Тип::Цел8, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел8, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелМеньше);
                    Ok(Тип::Лог)
                }
                ВидБинопа::Больше => {
                    проверить_типы(левое.лок(), &Тип::Цел8, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел8, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелБольше);
                    Ok(Тип::Лог)
                }
                ВидБинопа::Сложение => {
                    проверить_типы(левое.лок(), &Тип::Цел8, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел8, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелСложение);
                    Ok(Тип::Цел8)
                }
                ВидБинопа::Вычитание => {
                    проверить_типы(левое.лок(), &Тип::Цел8, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел8, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелВычитание);
                    Ok(Тип::Цел8)
                }
                ВидБинопа::Деление => {
                    проверить_типы(левое.лок(), &Тип::Цел8, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел8, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелДеление);
                    Ok(Тип::Цел8)
                }
                ВидБинопа::Остаток => {
                    проверить_типы(левое.лок(), &Тип::Цел8, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел8, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелОстаток);
                    Ok(Тип::Цел8)
                }
                ВидБинопа::Равно => {
                    if левый_тип != Тип::Цел8 {
                        сделать!(левое.лок(), "Сравнение типа «{тип}»", тип = левый_тип.текст());
                        return Err(())
                    }
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    пп.код.push(Инструкция::Пометка(ключ.clone()));
                    пп.код.push(Инструкция::ЦелРавно);
                    Ok(Тип::Лог)
                }
            }
        }

        Выражение::Вызов {имя, аргументы} => {
            match имя.текст.as_str() {
                "слепить" => {
                    let [тип, значение] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 2;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    let тип_цели = скомпилировать_тип(тип, &имена.константы)?;
                    let тип_значения = скомпилировать_выражение(пп, имена, параметры, &значение)?;

                    if !(тип_цели == Тип::Цел1 && тип_значения == Тип::Цел8) {
                        диагностика!(&имя.лок, "ОШИБКА", "Конвертация типа «{тип_значения}» в тип «{тип_цели}»",
                                     тип_значения = тип_значения.текст(),
                                     тип_цели = тип_цели.текст());
                        return Err(());
                    }

                    Ok(тип_цели)
                }
                "срез" => {
                    let [массив, начало_среза, размер_среза] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 3;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Срезы параметров");
                            return Err(())
                        }
                        if let Some(переменная) = имена.переменные.get(&имя.текст) {
                            if let Тип::Массив{размер: _, тип_элемента} = &переменная.тип {
                                let тип_размера_среза = скомпилировать_выражение(пп, имена, параметры, &размер_среза)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел8, &тип_размера_среза)?;

                                пп.заплатки_неиниц_указателей.push(пп.код.len());
                                пп.код.push(Инструкция::ПротолкнутьУказатель(переменная.адрес));

                                let тип_начала = скомпилировать_выражение(пп, имена, параметры, &начало_среза)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел8, &тип_начала)?;

                                пп.код.push(Инструкция::ПротолкнутьЦелое(тип_элемента.размер()));
                                пп.код.push(Инструкция::ЦелУмножение);
                                пп.код.push(Инструкция::ЦелСложение);

                                return Ok(Тип::Срез {
                                    тип_элемента: тип_элемента.clone()
                                });
                            } else {
                                // СДЕЛАТЬ: было бы полезно иметь срезы срезов.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Срезы возможны только для массивов на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Срез требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                _ => {
                    сделать!(&имя.лок, "Компиляция вызова выражения пользовательской процедуры");
                    Err(())
                }
            }
        }
    }
}

fn скомпилировать_утвержление(пп: &mut ПП, имена: &Имена, параметры: &Vec<СкомпПараметр>, утверждение: &Утверждение) -> Результат<()> {
    match утверждение {
        Утверждение::Присваивание{ключ, имя, значение} => {
            if let Some((порядок, параметр)) = параметры.iter().enumerate().find(|(_, параметр)| параметр.имя.текст == имя.текст) {
                if параметр.тип != Тип::Цел8 {
                    сделать!(&имя.лок, "Запись параметров типа «{тип}»", тип = параметр.тип.текст());
                    return Err(());
                }

                let тип = скомпилировать_выражение(пп, имена, параметры, &значение)?;
                проверить_типы(&значение.лок(), &параметр.тип, &тип)?;
                пп.код.push(Инструкция::Пометка(ключ.clone()));
                пп.код.push(Инструкция::ЗаписатьКадр(порядок));
                return Ok(());
            }

            if let Some(переменная) = имена.переменные.get(имя.текст.as_str()) {
                let тип = скомпилировать_выражение(пп, имена, параметры, &значение)?;
                проверить_типы(&значение.лок(), &переменная.тип, &тип)?;
                пп.код.push(Инструкция::Пометка(имя.clone()));
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция::ПротолкнутьУказатель(переменная.адрес));
                пп.код.push(Инструкция::Пометка(ключ.clone()));
                пп.код.push(Инструкция::Записать64);
                return Ok(())
            }

            диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = имя.текст);
            Err(())
        }
        Утверждение::ПрисваиваниеМассива{ключ,имя, индекс, значение} => {
            let переменная = if let Some(переменная) = имена.переменные.get(&имя.текст) {
                переменная
            } else {
                // СДЕЛАТЬ: Капитализировать все сообщения диагностики и заверщить их точкой в конце.
                диагностика!(&имя.лок, "ОШИБКА", "Переменной с именем «{имя}» не существует.", имя = имя.текст);
                return Err(());
            };

            let (тип_элемента, _размер) = if let Тип::Массив{тип_элемента, размер} = переменная.тип.clone() {
                (тип_элемента, размер)
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Переменная с именем «{имя}» не является массивом. Её нельзя индексировать.", имя = имя.текст);
                return Err(());
            };

            if *тип_элемента != Тип::Цел1 {
                сделать!(&имя.лок, "Мы пока не умеем присваивать массивы элементов типа {тип}", тип = тип_элемента.текст());
                return Err(());
            }

            let тип_значение = скомпилировать_выражение(пп, имена, параметры, значение)?;
            проверить_типы(значение.лок(), &тип_элемента, &тип_значение)?;

            пп.код.push(Инструкция::Пометка(ключ.clone()));

            пп.заплатки_неиниц_указателей.push(пп.код.len());
            пп.код.push(Инструкция::ПротолкнутьУказатель(переменная.адрес));

            // СДЕЛАТЬ: проверку входа за границы массива.

            let тип_индекса = скомпилировать_выражение(пп, имена, параметры, индекс)?;
            проверить_типы(&индекс.лок(), &Тип::Цел8, &тип_индекса)?;
            пп.код.push(Инструкция::ПротолкнутьЦелое(тип_элемента.размер()));
            пп.код.push(Инструкция::ЦелУмножение);
            пп.код.push(Инструкция::Записать64);
            Ok(())
        }
        Утверждение::Вызов{имя, аргументы} => {
            match имя.текст.as_str() {
                // СДЕЛАТЬ: не позволять переопределять процедуру «печать» в пользовательском коде.
                "печать" => {
                    for арг in аргументы {
                        let тип = скомпилировать_выражение(пп, имена, параметры, &арг)?;
                        пп.код.push(Инструкция::Пометка(имя.clone()));
                        match тип {
                            Тип::Строка => пп.код.push(Инструкция::ПечатьСтроки),
                            Тип::Цел8 => {
                                сделать!(арг.лок(), "печать цел(8)");
                                return Err(())
                            }
                            Тип::Цел1 => {
                                сделать!(арг.лок(), "печать цел(1)");
                                return Err(())
                            }
                            Тип::Лог => {
                                сделать!(арг.лок(), "печать логического типа");
                                return Err(())
                            }
                            Тип::Массив{..} => {
                                сделать!(арг.лок(), "печать массивов");
                                return Err(())
                            }
                            Тип::Срез{тип_элемента} => {
                                if *тип_элемента != Тип::Цел1 {
                                    сделать!(арг.лок(), "Печать срезов элементов типа «{тип}» пока не поддерживается",
                                             тип = тип_элемента.текст());
                                    return Err(())
                                }
                                пп.код.push(Инструкция::ПечатьСтроки);
                            }
                        }
                    }
                    Ok(())
                },
                _ => {
                    if let Some(процедура) = имена.процедуры.get(&имя.текст) {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = процедура.параметры.len();
                        if количество_аргументов != количество_параметров {
                            диагностика!(&имя.лок, "ОШИБКА",
                                         "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                         параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                         аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                            return Err(());
                        }

                        пп.код.push(Инструкция::СохранитьКадр);
                        for (параметр, аргумент) in процедура.параметры.iter().zip(аргументы.iter()) {
                            let тип = скомпилировать_выражение(пп, имена, параметры, аргумент)?;
                            проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                            if параметр.тип != Тип::Цел8 {
                                сделать!(&параметр.имя.лок, "Определение локальных переменных типа «{тип:?}»", тип = параметр.тип);
                                return Err(())
                            }
                        }
                        пп.код.push(Инструкция::Пометка(имя.clone()));
                        пп.код.push(Инструкция::ВызватьПроцедуру(процедура.точка_входа));
                        for параметр in &процедура.параметры {
                            if параметр.тип == Тип::Цел8 {
                                // СДЕЛАТЬ: Выталкивать одной инструкцией
                                пп.код.push(Инструкция::Вытолкнуть(1));
                            } else {
                                сделать!(&параметр.имя.лок, "Сброс локальных переменных типа «{тип:?}»", тип = параметр.тип);
                                return Err(())
                            }
                        }
                        пп.код.push(Инструкция::ВосстановитьКадр);
                        Ok(())
                    } else {
                        диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                        Err(())
                    }
                }
            }
        }
        Утверждение::Если{ключ, условие, тело} => {
            let тип = скомпилировать_выражение(пп, имена, параметры, &условие)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция::Пометка(ключ.clone()));
            пп.код.push(Инструкция::ЛогОтрицание);
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция::Ноп);
            for утверждение in тело.iter() {
                скомпилировать_утвержление(пп, имена, параметры, утверждение)?;
            }
            let точка_выхода = пп.код.len();
            пп.код[точка_условного_прыжка] = Инструкция::УсловныйПрыжок(точка_выхода);
            Ok(())
        }
        Утверждение::Вернуть{ключ} => {
            пп.код.push(Инструкция::Пометка(ключ.clone()));
            пп.код.push(Инструкция::Возврат);
            Ok(())
        }
        Утверждение::Пока{ключ, условие, тело} => {
            let точка_условия = пп.код.len();
            let тип = скомпилировать_выражение(пп, имена, параметры, &условие)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция::Пометка(ключ.clone()));
            пп.код.push(Инструкция::ЛогОтрицание);
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция::Ноп);
            for утверждение in тело.iter() {
                скомпилировать_утвержление(пп, имена, параметры, утверждение)?;
            }
            пп.код.push(Инструкция::Прыжок(точка_условия));
            let точка_выхода = пп.код.len();
            пп.код[точка_условного_прыжка] = Инструкция::УсловныйПрыжок(точка_выхода);
            Ok(())
        }
    }
}

fn скомпилировать_параметр(константы: &HashMap<String, СкомпКонстанта>, параметр: &Параметр) -> Результат<СкомпПараметр> {
    Ok(СкомпПараметр {
        имя: параметр.имя.clone(),
        тип: скомпилировать_тип(&параметр.тип, константы)?
    })
}

fn скомпилировать_процедуру(пп: &mut ПП, имена: &Имена, процедура: Процедура) -> Результат<СкомпПроцедура> {
    let mut параметры = Vec::new();
    for параметр in &процедура.параметры {
        параметры.push(скомпилировать_параметр(&имена.константы, параметр)?);
    }
    let точка_входа = пп.код.len();
    for утверждение in &процедура.тело {
        скомпилировать_утвержление(пп, имена, &параметры, утверждение)?;
    }
    пп.код.push(Инструкция::Возврат);
    Ok(СкомпПроцедура{
        имя: процедура.имя,
        параметры,
        точка_входа
    })
}

fn интерпретировать_выражение_константы(константы: &HashMap<String, СкомпКонстанта>, выражение: &Выражение) -> Результат<usize> {
    match выражение {
        &Выражение::Число(_, число) => Ok(число),
        Выражение::Строка(строка) => {
            сделать!(&строка.лок, "строковые константы");
            Err(())
        }
        Выражение::Идент(имя) => {
            if let Some(константа) = константы.get(имя.текст.as_str()) {
                Ok(константа.значение)
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, вид, левое, правое, ..} => {
            let левое_значение = интерпретировать_выражение_константы(константы, левое)?;
            let правое_значение = интерпретировать_выражение_константы(константы, правое)?;
            match вид {
                ВидБинопа::Равно | ВидБинопа::Меньше | ВидБинопа::Больше => {
                    сделать!(&ключ.лок, "булевые константы");
                    Err(())
                },
                ВидБинопа::Сложение => {
                    Ok(левое_значение + правое_значение)
                }
                ВидБинопа::Вычитание => {
                    Ok(левое_значение - правое_значение)
                }
                ВидБинопа::Деление => {
                    Ok(левое_значение / правое_значение)
                }
                ВидБинопа::Остаток => {
                    Ok(левое_значение % правое_значение)
                }
            }
        }
        Выражение::Вызов{имя, ..} => {
            сделать!(&имя.лок, "вызов функции в константном контексте");
            Err(())
        }
    }
}

fn скомпилировать_тип(тип: &Выражение, константы: &HashMap<String, СкомпКонстанта>) -> Результат<Тип> {
    match тип {
        Выражение::Число(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Число не является являться типом");
            Err(())
        }
        Выражение::Строка(лексема) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Строка не является являться типом");
            Err(())
        }
        Выражение::Идент(лексема) => match лексема.текст.as_str() {
            "цел" => Ok(Тип::Цел8),
            "строка" => Ok(Тип::Строка),
            "лог" => Ok(Тип::Лог),
            _ => {
                диагностика!(&лексема.лок, "ОШИБКА", "Неизвестный тип «{тип}»", тип = лексема.текст);
                Err(())
            }
        }
        Выражение::Вызов{имя, аргументы} => match имя.текст.as_str() {
            "цел" => {
                let [размер] = аргументы.as_slice() else {
                    let количество_параметров = 1;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let размер = интерпретировать_выражение_константы(константы, &размер)?;
                match размер {
                    1 => Ok(Тип::Цел1),
                    8 => Ok(Тип::Цел8),
                    _ => {
                        диагностика!(&имя.лок, "ОШИБКА", "Неподдерживаемый размер целых чисел {размер}. На данный момент поддерживаются только 1 и 8.");
                        Err(())
                    }
                }
            }
            "массив" => {
                let [размер, тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 2;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let размер = интерпретировать_выражение_константы(константы, &размер)?;
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, константы)?);
                Ok(Тип::Массив{размер, тип_элемента})
            }
            "срез" => {
                let [тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 1;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, константы)?);
                Ok(Тип::Срез{тип_элемента})
            }
            _ => {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестный параметризированный тип «{тип}»", тип = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные бинарные операции не поддерживаются в типах");
            Err(())
        }
    }
}

impl Программа {
    pub fn скомпилировать_лексемы(&mut self, лекс: &mut Лексер) -> Результат<()> {
        loop {
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::КлючПер,
                ВидЛексемы::КлючПро,
                ВидЛексемы::КлючКонст,
                ВидЛексемы::Конец,
            ])?;
            match ключ.вид {
                ВидЛексемы::КлючПер => {
                    let синтаксис = Переменная::разобрать(лекс)?;
                    let имя = синтаксис.имя;
                    self.имена.верифицировать_переопределение_имени(&имя)?;
                    let тип = скомпилировать_тип(&синтаксис.тип, &self.имена.константы)?;
                    let адрес = self.пп.размер_неиниц_данных;
                    self.пп.размер_неиниц_данных += тип.размер();
                    if let Some(_) = self.имена.переменные.insert(имя.текст.clone(), СкомпПеременная {имя, тип, адрес}) {
                        unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючПро => {
                    self.пп.код.push(Инструкция::Пометка(ключ));
                    let процедура = Процедура::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&процедура.имя)?;
                    let скомп_процедура = скомпилировать_процедуру(&mut self.пп, &self.имена, процедура)?;
                    if let Some(_) = self.имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                        unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючКонст => {
                    let константа = Константа::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&константа.имя)?;
                    let значение = интерпретировать_выражение_константы(&self.имена.константы, &константа.выражение)?;
                    if let Some(_) = self.имена.константы.insert(константа.имя.текст.clone(), СкомпКонстанта { синтаксис: константа, значение }) {
                        unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::Конец => break,
                _ => unreachable!(),
            }
        }

        for индекс in &self.пп.заплатки_неиниц_указателей {
            if let Some(Инструкция::ПротолкнутьУказатель(указатель)) = self.пп.код.get_mut(*индекс) {
                *указатель += self.пп.иниц_данные.len();
            } else {
                unreachable!("Ошибка в процессе сбора заплаток указателей на неинициализированные данные. Каждый индекс такой заплатки должен указывать на инструкцию ПротолкнутьУказатель");
            }
        }
        Ok(())
    }
}
