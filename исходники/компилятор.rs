/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use std::path::PathBuf;
use синтаксис::*;
use диагностика::*;
use лексика::*;
use типизация::*;

/// Инструкция промежуточного представления
#[derive(Debug)]
pub enum ВидИнструкции {
    Ноп,
    /// Протолкнуть целое значение на стек аргументов.
    ПротолкнутьЦел(usize),
    /// Протолкнуть указатель на данные.
    ///
    /// Эта инстуркция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ПротолкнутьУказатель(usize), // СДЕЛАТЬ: по возможности, использовать u64 вместо usize для значений пп
    Вытолкнуть(usize),
    Обменять,
    СохранитьКадр,
    ВосстановитьКадр,
    // СДЕЛАТЬ: смещение чтения и записи кадра очень странные. Нужно их поправить так, чтобы они имели больше смысла.
    // Странность возникла в результате экспериментов потому, что я не знал, что нужно делать.
    ПрочитатьКадр(i32),
    ЗаписатьКадр(i32),
    Записать8,
    Записать32,
    Записать64,
    Прочитать32,
    Прочитать64,
    ЦелСложение,
    ЦелВычитание,
    ЦелУмножение,
    ЦелДеление,
    ЦелОстаток,
    ЦелМеньше,
    ЦелБольше,
    ЦелРавно,
    КонвертЦел64Вещ32,
    КонвертВещ32Цел64,
    Вещ32Умножение,
    Вещ32Сложение,
    Вещ32Меньше,
    Вещ32Больше,
    Вещ32Инверт,
    ЛогОтрицание,
    БитИли,
    ПечатьСтроки,
    Ввод,
    Возврат,
    ВызватьВнутреннююПроцедуру(usize),
    ВызватьВнешнююПроцедуру{индекс: usize, арность: usize, результат: Option<Тип>},
    // СДЕЛАТЬ: инструкции изменения потока исполнения должны принимать относительное смещение.
    // Данный подход позволяет создавать легко перемещаемый код. Хотя, я не уверен, что это подойдет
    // для ВызватьВнутренююПроцедуру.
    Прыжок(usize),
    УсловныйПрыжок(usize),
    СисВызов{ арность: usize },
}

pub struct Инструкция {
    pub лок: Лок,
    pub вид: ВидИнструкции,
}

#[derive(Clone)]
pub struct СкомпПеременная {
    pub имя: Лексема,
    pub тип: Тип,
    pub адрес: usize,
}

pub struct СкомпПараметр {
    pub имя: Лексема,
    pub тип: Тип,
}

pub enum ТочкаВхода {
    Внутреняя { адрес: usize },
    Внешняя { индекс: usize },
}

impl ТочкаВхода {
    fn внутреняя(&self) -> bool {
        match self {
            ТочкаВхода::Внутреняя{..} => true,
            ТочкаВхода::Внешняя{..} => false,
        }
    }
}

pub struct СкомпПроцедура {
    pub имя: Лексема,
    pub параметры: Vec<СкомпПараметр>,
    pub тип_результата: Option<Тип>,
    pub точка_входа: ТочкаВхода,
}

#[derive(Debug)]
pub struct СкомпКонстанта {
    pub синтаксис: Константа,
    pub значение: usize,
}

/// Промежуточное Представление
#[derive(Default)]
pub struct ПП {
    pub код: Vec<Инструкция>,
    pub иниц_данные: Vec<u8>,
    pub размер_неиниц_данных: usize,
    pub заплатки_неиниц_указателей: Vec<usize>,
    pub строки: HashMap<String, usize>,
    pub внешние_символы: HashMap<String, usize>,
    pub библиотеки: HashMap<String, usize>,
}

impl ПП {
    pub fn вывалить(&self, точка_входа: usize) {
        println!("Инструкции ({количество} {инструкций}):",
                 количество = self.код.len(),
                 инструкций = ЧИСУЩ_ИНСТРУКЦИЙ.текст(self.код.len()));
        let ширина_столбца_индекса = self.код.len().to_string().len();
        let mut начало = 0;
        while начало < self.код.len() {
            let mut конец = начало;
            while конец < self.код.len() && self.код[начало].лок == self.код[конец].лок{
                конец += 1;
            }
            let Лок{путь_к_файлу, строка, столбец} = &self.код[начало].лок;
            println!("{путь_к_файлу}:{строка}:{столбец}: ", путь_к_файлу = путь_к_файлу.display());
            for индекс in начало..конец {
                print!("    {индекс:0>ширина_столбца_индекса$}: {вид:?}", вид = self.код[индекс].вид);
                if точка_входа == индекс {
                    print!(" <- точка входа");
                }
                println!();
            }
            начало = конец;
        }
        println!();
        // СДЕЛАТЬ: Показать где находятся адреса переменных в памяти
        println!("Инициализированные данные ({размер} {байт}):",
                 размер = self.иниц_данные.len(),
                 байт = ЧИСУЩ_БАЙТ.текст(self.иниц_данные.len()));
        const ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ: usize = 16;
        for строка in 0..self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ {
            let адрес = строка*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        let остаток = self.иниц_данные.len()%ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
        if остаток > 0 {
            let адрес = self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + остаток];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        println!();
        println!("Размер неинициализированных данных:");
        println!("    {размер} {байт}",
                 размер = self.размер_неиниц_данных,
                 байт = ЧИСУЩ_БАЙТ.текст(self.размер_неиниц_данных))
    }
}

#[derive(Default)]
pub struct Имена {
    pub константы: HashMap<String, СкомпКонстанта>,
    pub процедуры: HashMap<String, СкомпПроцедура>,
    pub переменные: HashMap<String, СкомпПеременная>,
}

impl Имена {
    fn верифицировать_переопределение_имени(&self, имя: &Лексема) -> Результат<()> {
        if let Some(существующая_переменная) = self.переменные.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует переменная с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_процедура) = self.процедуры.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует процедура с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_константа) = self.константы.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует константа с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_константа.синтаксис.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        Ok(())
    }
}

#[derive(Default)]
pub struct Программа {
    pub пп: ПП,
    pub имена: Имена,
}

fn скомпилировать_выражение(пп: &mut ПП, имена: &Имена, параметры: &Vec<СкомпПараметр>, выражение: &Выражение) -> Результат<Тип> {
    match выражение {
        Выражение::ЦелЧисло(лексема, число) => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(*число), лок: лексема.лок.clone() });
            Ok(Тип::Цел64)
        },
        Выражение::ВещЧисло(лексема, число) => {
            let число = u32::from_le_bytes(число.to_le_bytes()) as usize;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(число), лок: лексема.лок.clone() });
            Ok(Тип::Вещ32)
        },
        Выражение::Строка(строка) => {
            let (указатель, длинна) = if let Some(указатель) = пп.строки.get(&строка.текст) {
                (*указатель, строка.текст.len())
            } else {
                let указатель = пп.иниц_данные.len();
                let длинна = строка.текст.len();
                пп.иниц_данные.extend(строка.текст.as_bytes());
                пп.иниц_данные.push(0); // ЗАМЕТКА: нулл-терминатор на случае если мы захотим что-то передать в сишный код
                пп.строки.insert(строка.текст.clone(), указатель);
                (указатель, длинна)
            };
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(длинна), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(указатель), лок: строка.лок.clone() });
            Ok(Тип::Строка)
        }
        Выражение::Идент(лексема) => {
            if let Some(константа) = имена.константы.get(&лексема.текст) {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(константа.значение), лок: лексема.лок.clone() });
                return Ok(Тип::Цел64);
            }
            if let Some((порядок, параметр)) = параметры.iter().enumerate().find(|(_, параметр)| параметр.имя.текст == лексема.текст) {
                match параметр.тип {
                    Тип::Цел64 | Тип::Лог => {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПрочитатьКадр(-(порядок as i32) - 3), лок: лексема.лок.clone() });
                        return Ok(параметр.тип.clone());
                    }
                    _ => {
                        сделать!(&лексема.лок, "Чтение параметров типа «{тип}»", тип = параметр.тип.текст());
                        return Err(());
                    }
                }
            }
            if let Some(переменная) = имена.переменные.get(&лексема.текст) {
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: лексема.лок.clone() });
                match переменная.тип {
                    Тип::Цел64 => {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: лексема.лок.clone()});
                        return Ok(переменная.тип.clone());
                    }
                    Тип::Вещ32 => {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать32, лок: лексема.лок.clone()});
                        return Ok(переменная.тип.clone());
                    }
                    _ => {
                        сделать!(&лексема.лок, "Чтение переменных тип «{тип}»", тип = переменная.тип.текст());
                        return Err(())
                    }
                }
            }
            диагностика!(&лексема.лок, "ОШИБКА",
                         "не существует ни констант, ни переменных с имением «{имя}»",
                         имя = &лексема.текст);
            Err(())
        }
        Выражение::Биноп {ключ, вид, левое, правое} => {
            match вид {
                ВидБинопа::Меньше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелМеньше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Меньше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(Тип::Лог)
                }
                ВидБинопа::Больше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Больше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(Тип::Лог)
                }
                ВидБинопа::Или => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(левое.лок(), &Тип::Лог, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Лог, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::БитИли, лок: ключ.лок.clone() });
                    Ok(Тип::Лог)
                }
                ВидБинопа::Сложение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Сложение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Сложение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Вычитание => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелВычитание, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Умножение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Умножение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Перемножение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Деление => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелДеление, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Остаток => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелОстаток, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Равно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, параметры, &левое)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, параметры, &правое)?;
                    if левый_тип != Тип::Цел64 {
                        сделать!(левое.лок(), "Сравнение типа «{тип}»", тип = левый_тип.текст());
                        return Err(())
                    }
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелРавно, лок: ключ.лок.clone() });
                    Ok(Тип::Лог)
                }
                ВидБинопа::Как => {
                    let значение = левое;
                    let тип = правое;
                    let тип_цели = скомпилировать_тип(тип, &имена.константы)?;
                    let тип_значения = скомпилировать_выражение(пп, имена, параметры, &значение)?;

                    if тип_значения == тип_цели {
                        return Ok(тип_цели);
                    }

                    match (&тип_значения, &тип_цели) {
                        (Тип::Цел64, Тип::Цел8) => Ok(тип_цели),
                        (Тип::Цел64, Тип::Вещ32) => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертЦел64Вещ32, лок: ключ.лок.clone() });
                            Ok(тип_цели)
                        }
                        (Тип::Вещ32, Тип::Цел64) => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Цел64, лок: ключ.лок.clone() });
                            Ok(тип_цели)
                        }
                        _ => {
                            сделать!(&ключ.лок, "Конвертация типа «{тип_значения}» в тип «{тип_цели}»",
                                     тип_значения = тип_значения.текст(),
                                     тип_цели = тип_цели.текст());
                            return Err(());
                        }
                    }
                }
            }
        }

        Выражение::УнарныйМинус {ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, параметры, &выражение)?;
            match тип {
                Тип::Вещ32 => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Инверт, лок: ключ.лок.clone() });
                    Ok(тип)
                }
                _ => {
                    диагностика!(&ключ.лок, "ОШИБКА", "Тип «{тип}» не может быть отрицательным", тип = тип.текст());
                    Err(())
                }
            }
        }

        Выражение::Вызов {имя, аргументы} => {
            match имя.текст.as_str() {
                // СДЕЛАТЬ: не позволять переопределять процедуру интринсиков в пользовательском коде.
                "ввод" => {
                    let [массив] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 1;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };
                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Ввод параметров");
                            return Err(())
                        }
                        if let Some(переменная) = имена.переменные.get(&имя.текст) {
                            if let Тип::Массив{размер, тип_элемента} = &переменная.тип {
                                if **тип_элемента != Тип::Цел8 {
                                    диагностика!(&имя.лок, "ОШИБКА", "Ввод возможет только в массива элементов «{тип_элемента}»", тип_элемента = тип_элемента.текст());
                                    return Err(())
                                }

                                пп.заплатки_неиниц_указателей.push(пп.код.len());
                                // СДЕЛАТЬ: поменять местами аргументы по аналогии с ПечатьСтроки
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(*размер), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Ввод, лок: имя.лок.clone() });
                                return Ok(Тип::Цел64);
                            } else {
                                // СДЕЛАТЬ: было бы полезно читать ввод в срезы.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Ввод можно осуществлять только в массивы на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Ввод требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                "срез" => {
                    let [массив, начало_среза, размер_среза] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 3;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Срезы параметров");
                            return Err(())
                        }
                        if let Some(переменная) = имена.переменные.get(&имя.текст) {
                            if let Тип::Массив{размер: _, тип_элемента} = &переменная.тип {
                                let тип_размера_среза = скомпилировать_выражение(пп, имена, параметры, &размер_среза)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел64, &тип_размера_среза)?;

                                пп.заплатки_неиниц_указателей.push(пп.код.len());
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });

                                let тип_начала = скомпилировать_выражение(пп, имена, параметры, &начало_среза)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел64, &тип_начала)?;

                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(тип_элемента.размер()), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });

                                return Ok(Тип::Срез {
                                    тип_элемента: тип_элемента.clone()
                                });
                            } else {
                                // СДЕЛАТЬ: было бы полезно иметь срезы срезов.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Срезы возможны только для массивов на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Срез требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                "сисвызов" => {
                    if аргументы.len() == 0 {
                        сделать!(&имя.лок, "Диагностика некорректной арности «сисвызов»-ов");
                        return Err(());
                    }
                    let арность = аргументы.len() - 1;

                    for аргумент in аргументы {
                        let тип_аргумента = скомпилировать_выражение(пп, имена, параметры, аргумент)?;
                        проверить_типы(&аргумент.лок(), &Тип::Цел64, &тип_аргумента)?;
                    }

                    пп.код.push(Инструкция{ вид: ВидИнструкции::СисВызов{арность}, лок: имя.лок.clone() });
                    Ok(Тип::Цел64)
                }
                "адрес" => {
                    let [срез] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 1;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    let тип_среза = скомпилировать_выражение(пп, имена, параметры, &срез)?;
                    match тип_среза {
                        Тип::Строка => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Обменять, лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вытолкнуть(1), лок: имя.лок.clone()});
                            Ok(Тип::Цел64)
                        }
                        Тип::Срез{..} => {
                            сделать!(&срез.лок(), "Извлечение адреса среза");
                            Err(())
                        }
                        _ => {
                            диагностика!(&срез.лок(), "ОШИБКА", "Несоответствие типов данных. Ожидался тип «строка», либо «срез», но повстречался тип «{действительный}»",
                                         действительный = тип_среза.текст());
                            Err(())
                        }
                    }
                }
                _ => {
                    if let Some(процедура) = имена.процедуры.get(&имя.текст) {
                        let тип_результата = if let Some(тип_результата) = &процедура.тип_результата {
                            тип_результата.clone()
                        } else {
                            диагностика!(&имя.лок, "ОШИБКА", "Данная процедура ничего не возвращает. Её нельзя использовать как выражение. Только как утверждение.");
                            return Err(())
                        };

                        // СДЕЛАТЬ: дупликация кода между компиляцией вызова процедур как выражений и как утверждений.

                        let количество_аргументов = аргументы.len();
                        let количество_параметров = процедура.параметры.len();
                        if количество_аргументов != количество_параметров {
                            диагностика!(&имя.лок, "ОШИБКА",
                                         "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                         параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                         аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                            return Err(());
                        }

                        if тип_результата != Тип::Цел64 && тип_результата != Тип::Лог && тип_результата != Тип::Вещ32 {
                            сделать!(&имя.лок, "Компиляция вызова процедур, которые возвращают тип «{тип}»", тип = тип_результата.текст());
                            return Err(())
                        }

                        if процедура.точка_входа.внутреняя() {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(0), лок: имя.лок.clone() }); // Результат
                        }
                        for (параметр, аргумент) in процедура.параметры.iter().zip(аргументы.iter()).rev() {
                            let тип = скомпилировать_выражение(пп, имена, параметры, аргумент)?;
                            проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                            match параметр.тип {
                                Тип::Цел64 | Тип::Лог => {}
                                _ => {
                                    сделать!(&параметр.имя.лок, "Определение локальных переменных типа «{тип:?}»", тип = параметр.тип);
                                    return Err(())
                                }
                            }
                        }
                        вызвать_процедуру(имя.лок.clone(), &процедура, &mut пп.код)?;
                        Ok(тип_результата)
                    } else {
                        диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                        Err(())
                    }
                }
            }
        }

        Выражение::Отрицание{ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, параметры, выражение)?;
            проверить_типы(&выражение.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            Ok(Тип::Лог)
        }
    }
}

fn достать_и_проверить_процедуру_печати<'ы>(имена: &'ы Имена, имя_принтера: &str, тип: &Тип, лок: &Лок) -> Результат<&'ы СкомпПроцедура> {
    if let Some(процедура) = имена.процедуры.get(имя_принтера) {
        let арность = 1;
        let [параметр] = процедура.параметры.as_slice() else {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает {число_параметров}", число_параметров = процедура.параметры.len());
            return Err(());
        };
        if параметр.тип != *тип {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает тип «{тип}»", тип = параметр.тип.текст());
            return Err(());
        }

        Ok(процедура)
    } else {
        диагностика!(лок, "ОШИБКА", "Чтобы печатать значения типа «{тип}», нужно чтобы где-нибудь была определена процедура с именем «{имя_принтера}», которая принимает один аргумент типа «{тип}» и печатает его. Мы не смогли найти определение такой процедуры. Обычно все нужные процедуры печати определены в модуле «прелюдия». Возможно мы не смогли его загрузить.", тип = тип.текст());
        Err(())
    }
}

fn вызвать_процедуру(лок: Лок, процедура: &СкомпПроцедура, код: &mut Vec<Инструкция>) -> Результат<()> {
    match &процедура.точка_входа {
        &ТочкаВхода::Внутреняя{адрес} => {
            код.push(Инструкция {
                вид: ВидИнструкции::ВызватьВнутреннююПроцедуру(адрес),
                лок: лок.clone(),
            });
            for параметр in &процедура.параметры {
                match параметр.тип {
                    Тип::Цел64 | Тип::Лог => {
                        // СДЕЛАТЬ: Выталкивать одной инструкцией
                        код.push(Инструкция{ вид: ВидИнструкции::Вытолкнуть(1), лок: лок.clone() });
                    }
                    _ => {
                        сделать!(&параметр.имя.лок, "Сброс локальных переменных типа «{тип:?}»", тип = параметр.тип);
                        return Err(())
                    }
                }
            }
        },
        &ТочкаВхода::Внешняя{индекс} => {
            for параметр in &процедура.параметры {
                if параметр.тип != Тип::Цел64 {
                    сделать!(&лок, "Вызов внешней процедуры с параметрами типа «{тип}»", тип = параметр.тип.текст());
                    return Err(())
                }
            }

            код.push(Инструкция {
                вид: ВидИнструкции::ВызватьВнешнююПроцедуру{
                    индекс,
                    арность: процедура.параметры.len(),
                    результат: процедура.тип_результата.clone(),
                },
                лок,
            });
        },
    }
    Ok(())
}

fn скомпилировать_утвержление(пп: &mut ПП, имена: &Имена, параметры: &Vec<СкомпПараметр>, утверждение: &Утверждение) -> Результат<()> {
    match утверждение {
        Утверждение::Присваивание{ключ, имя, значение} => {
            if let Some((порядок, параметр)) = параметры.iter().enumerate().find(|(_, параметр)| параметр.имя.текст == имя.текст) {
                if параметр.тип != Тип::Цел64 {
                    сделать!(&имя.лок, "Запись параметров типа «{тип}»", тип = параметр.тип.текст());
                    return Err(());
                }

                let тип = скомпилировать_выражение(пп, имена, параметры, &значение)?;
                проверить_типы(&значение.лок(), &параметр.тип, &тип)?;
                пп.код.push(Инструкция{ вид: ВидИнструкции::ЗаписатьКадр(-(порядок as i32) - 3), лок: ключ.лок.clone() });
                return Ok(());
            }

            if let Some(переменная) = имена.переменные.get(имя.текст.as_str()) {
                let тип = скомпилировать_выражение(пп, имена, параметры, &значение)?;
                проверить_типы(&значение.лок(), &переменная.тип, &тип)?;
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });

                match переменная.тип {
                    Тип::Цел64 => пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: ключ.лок.clone() }),
                    Тип::Вещ32 => пп.код.push(Инструкция{ вид: ВидИнструкции::Записать32, лок: ключ.лок.clone() }),
                    _ => {
                        сделать!(&имя.лок, "Запись переменных типа «{тип}»", тип = переменная.тип.текст());
                        return Err(());
                    }
                }

                return Ok(())
            }

            диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = имя.текст);
            Err(())
        }
        Утверждение::ПрисваиваниеМассива{ключ, имя, индекс, значение} => {
            let переменная = if let Some(переменная) = имена.переменные.get(&имя.текст) {
                переменная
            } else {
                // СДЕЛАТЬ: Капитализировать все сообщения диагностики и заверщить их точкой в конце.
                диагностика!(&имя.лок, "ОШИБКА", "Переменной с именем «{имя}» не существует.", имя = имя.текст);
                return Err(());
            };

            let (тип_элемента, _размер) = if let Тип::Массив{тип_элемента, размер} = переменная.тип.clone() {
                (тип_элемента, размер)
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Переменная с именем «{имя}» не является массивом. Её нельзя индексировать.", имя = имя.текст);
                return Err(());
            };

            if *тип_элемента != Тип::Цел8 {
                сделать!(&имя.лок, "Мы пока не умеем присваивать массивы элементов типа {тип}", тип = тип_элемента.текст());
                return Err(());
            }

            let тип_значения = скомпилировать_выражение(пп, имена, параметры, значение)?;
            проверить_типы(значение.лок(), &тип_элемента, &тип_значения)?;

            пп.заплатки_неиниц_указателей.push(пп.код.len());
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });

            // СДЕЛАТЬ: проверку входа за границы массива.

            let тип_индекса = скомпилировать_выражение(пп, имена, параметры, индекс)?;
            проверить_типы(&индекс.лок(), &Тип::Цел64, &тип_индекса)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(тип_элемента.размер()), лок: имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать8, лок: ключ.лок.clone() });
            Ok(())
        }
        Утверждение::Вызов{имя, аргументы} => {
            match имя.текст.as_str() {
                // СДЕЛАТЬ: не позволять переопределять процедуру «печать» в пользовательском коде.
                "печать" => {
                    for арг in аргументы {
                        let тип = скомпилировать_выражение(пп, имена, параметры, &арг)?;
                        match тип {
                            Тип::Строка => {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: арг.лок().clone() })
                            }
                            Тип::Цел64 => {
                                let процедура = достать_и_проверить_процедуру_печати(имена, "печать_цел", &тип, &арг.лок())?;
                                вызвать_процедуру(арг.лок().clone(), процедура, &mut пп.код)?;
                            }
                            Тип::Лог => {
                                let процедура = достать_и_проверить_процедуру_печати(имена, "печать_лог", &тип, &арг.лок())?;
                                вызвать_процедуру(арг.лок().clone(), процедура, &mut пп.код)?;
                            }
                            Тип::Срез{тип_элемента} => {
                                if *тип_элемента != Тип::Цел8 {
                                    сделать!(арг.лок(), "Печать срезов элементов типа «{тип}» пока не поддерживается",
                                             тип = тип_элемента.текст());
                                    return Err(())
                                }
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: имя.лок.clone() });
                            }
                            _ => {
                                сделать!(арг.лок(), "печать переменных типа «{тип}»", тип = тип.текст());
                                return Err(())
                            }
                        }
                    }
                    Ok(())
                },
                _ => {
                    if let Some(процедура) = имена.процедуры.get(&имя.текст) {
                        if процедура.тип_результата.is_some() {
                            сделать!(&процедура.имя.лок, "Вызов процедур возвращающих значение в контексте утверждения");
                            return Err(())
                        }

                        let количество_аргументов = аргументы.len();
                        let количество_параметров = процедура.параметры.len();
                        if количество_аргументов != количество_параметров {
                            диагностика!(&имя.лок, "ОШИБКА",
                                         "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                         параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                         аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                            return Err(());
                        }

                        for (параметр, аргумент) in процедура.параметры.iter().zip(аргументы.iter()).rev() {
                            let тип = скомпилировать_выражение(пп, имена, параметры, аргумент)?;
                            проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                            match параметр.тип {
                                Тип::Цел64 | Тип::Лог => {}
                                _ => {
                                    сделать!(&параметр.имя.лок, "Определение локальных переменных типа «{тип:?}»", тип = параметр.тип);
                                    return Err(())
                                }
                            }
                        }
                        вызвать_процедуру(имя.лок.clone(), процедура, &mut пп.код)?;
                        Ok(())
                    } else {
                        диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                        Err(())
                    }
                }
            }
        }
        Утверждение::Если{ключ, условие, тело, иначе} => {
            let тип = скомпилировать_выражение(пп, имена, параметры, &условие)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
            for утверждение in тело.iter() {
                скомпилировать_утвержление(пп, имена, параметры, утверждение)?;
            }

            if иначе.len() == 0 {
                let точка_выхода = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            } else {
                let точка_конца_тела = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });

                let точка_иначе = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_иначе);

                for утверждение in иначе.iter() {
                    скомпилировать_утвержление(пп, имена, параметры, утверждение)?;
                }

                let точка_выхода = пп.код.len();
                пп.код[точка_конца_тела].вид = ВидИнструкции::Прыжок(точка_выхода);
            }
            Ok(())
        }
        Утверждение::Вернуть{ключ, выражение} => {
            if let Some(выражение) = выражение {
                let тип = скомпилировать_выражение(пп, имена, параметры, &выражение)?;
                if тип != Тип::Цел64 {
                    сделать!(&выражение.лок(), "Компиляция типа «{тип}»", тип = тип.текст());
                    return Err(())
                }
                пп.код.push(Инструкция{ вид: ВидИнструкции::ЗаписатьКадр(-(параметры.len() as i32) - 3), лок: ключ.лок.clone() });
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: ключ.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Возврат, лок: ключ.лок.clone() });
            Ok(())
        }
        Утверждение::Пока{ключ, условие, тело} => {
            let точка_условия = пп.код.len();
            let тип = скомпилировать_выражение(пп, имена, параметры, &условие)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
            for утверждение in тело.iter() {
                скомпилировать_утвержление(пп, имена, параметры, утверждение)?;
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(точка_условия), лок: ключ.лок.clone() });
            let точка_выхода = пп.код.len();
            пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            Ok(())
        }
    }
}

fn скомпилировать_параметр(константы: &HashMap<String, СкомпКонстанта>, параметр: &Параметр) -> Результат<СкомпПараметр> {
    Ok(СкомпПараметр {
        имя: параметр.имя.clone(),
        тип: скомпилировать_тип(&параметр.тип, константы)?
    })
}

fn скомпилировать_процедуру(пп: &mut ПП, имена: &Имена, процедура: Процедура) -> Результат<СкомпПроцедура> {
    let mut параметры = Vec::new();
    for параметр in &процедура.параметры {
        параметры.push(скомпилировать_параметр(&имена.константы, параметр)?);
    }
    let точка_входа = match процедура.тело {
        ТелоПроцедуры::Внутренее{блок} => {
            let адрес = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::СохранитьКадр, лок: процедура.имя.лок.clone() });
            for утверждение in &блок {
                скомпилировать_утвержление(пп, имена, &параметры, утверждение)?;
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадр, лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Возврат, лок: процедура.имя.лок.clone() });
            ТочкаВхода::Внутреняя{адрес}
        }
        ТелоПроцедуры::Внешнее{символ} => {
            let индекс = пп.внешние_символы.len();
            let индекс = *пп.внешние_символы.entry(символ.текст).or_insert(индекс);
            ТочкаВхода::Внешняя{индекс}
        }
    };
    let тип_результата = if let Some(тип) = процедура.тип_результата {
        Some(скомпилировать_тип(&тип, &имена.константы)?)
    } else {
        None
    };
    Ok(СкомпПроцедура{
        имя: процедура.имя,
        параметры,
        точка_входа,
        тип_результата,
    })
}

fn интерпретировать_выражение_константы(константы: &HashMap<String, СкомпКонстанта>, выражение: &Выражение) -> Результат<usize> {
    match выражение {
        &Выражение::ЦелЧисло(_, число) => Ok(число),
        Выражение::ВещЧисло(лексема, _) => {
            сделать!(&лексема.лок, "вещественные константы");
            Err(())
        },
        Выражение::Строка(строка) => {
            сделать!(&строка.лок, "строковые константы");
            Err(())
        }
        Выражение::Идент(имя) => {
            if let Some(константа) = константы.get(имя.текст.as_str()) {
                Ok(константа.значение)
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, вид, левое, правое, ..} => {
            let левое_значение = интерпретировать_выражение_константы(константы, левое)?;
            let правое_значение = интерпретировать_выражение_константы(константы, правое)?;
            match вид {
                ВидБинопа::Равно | ВидБинопа::Меньше | ВидБинопа::Больше | ВидБинопа::Или => {
                    сделать!(&ключ.лок, "булевые константы");
                    Err(())
                },
                ВидБинопа::Сложение => {
                    Ok(левое_значение + правое_значение)
                }
                ВидБинопа::Вычитание => {
                    Ok(левое_значение - правое_значение)
                }
                ВидБинопа::Умножение => {
                    Ok(левое_значение * правое_значение)
                }
                ВидБинопа::Деление => {
                    Ok(левое_значение / правое_значение)
                }
                ВидБинопа::Остаток => {
                    Ok(левое_значение % правое_значение)
                }
                ВидБинопа::Как => {
                    сделать!(&ключ.лок, "Мы пока что вообще не имеем типов в константах");
                    Err(())
                }
            }
        }
        Выражение::УнарныйМинус {ключ, выражение: _} => {
            сделать!(&ключ.лок, "константы пока что не могу быть отрицательными");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            сделать!(&ключ.лок, "булевые константы");
            Err(())
        }
        Выражение::Вызов{имя, ..} => {
            сделать!(&имя.лок, "вызов функции в константном контексте");
            Err(())
        }
    }
}

fn скомпилировать_тип(тип: &Выражение, константы: &HashMap<String, СкомпКонстанта>) -> Результат<Тип> {
    match тип {
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не является являться типом");
            Err(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не является являться типом");
            Err(())
        }
        Выражение::Строка(лексема) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Строка не является являться типом");
            Err(())
        }
        Выражение::Идент(лексема) => match лексема.текст.as_str() {
            "цел" | "цел64" => Ok(Тип::Цел64),
            "цел8" => Ok(Тип::Цел8),
            "вещ" | "вещ32" => Ok(Тип::Вещ32),
            "строка" => Ok(Тип::Строка),
            "лог" => Ok(Тип::Лог),
            _ => {
                диагностика!(&лексема.лок, "ОШИБКА", "Неизвестный тип «{тип}»", тип = лексема.текст);
                Err(())
            }
        }
        Выражение::Вызов{имя, аргументы} => match имя.текст.as_str() {
            "массив" => {
                let [размер, тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 2;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let размер = интерпретировать_выражение_константы(константы, &размер)?;
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, константы)?);
                Ok(Тип::Массив{размер, тип_элемента})
            }
            "срез" => {
                let [тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 1;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, константы)?);
                Ok(Тип::Срез{тип_элемента})
            }
            _ => {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестный параметризированный тип «{тип}»", тип = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные бинарные операции не поддерживаются в типах");
            Err(())
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные унарные операции не поддерживаются в типах");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не поддерживается в типах");
            // Хотя, это довольно таки интересна идея. Тип «не цел». Любой тип, кроме целого...
            Err(())
        }
    }
}

impl Программа {
    pub fn скомпилировать_лексемы(&mut self, лекс: &mut Лексер) -> Результат<()> {
        loop {
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::КлючПер,
                ВидЛексемы::КлючПро,
                ВидЛексемы::КлючКонст,
                ВидЛексемы::КлючВкл,
                ВидЛексемы::КлючБибл,
                ВидЛексемы::Конец,
            ])?;
            match ключ.вид {
                ВидЛексемы::КлючПер => {
                    let синтаксис = Переменная::разобрать(лекс)?;
                    let имя = синтаксис.имя;
                    self.имена.верифицировать_переопределение_имени(&имя)?;
                    let тип = скомпилировать_тип(&синтаксис.тип, &self.имена.константы)?;
                    let адрес = self.пп.размер_неиниц_данных;
                    self.пп.размер_неиниц_данных += тип.размер();
                    if let Some(_) = self.имена.переменные.insert(имя.текст.clone(), СкомпПеременная {имя, тип, адрес}) {
                        unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючПро => {
                    let процедура = Процедура::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&процедура.имя)?;
                    let скомп_процедура = скомпилировать_процедуру(&mut self.пп, &self.имена, процедура)?;
                    if let Some(_) = self.имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                        unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючКонст => {
                    let константа = Константа::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&константа.имя)?;
                    let значение = интерпретировать_выражение_константы(&self.имена.константы, &константа.выражение)?;
                    if let Some(_) = self.имена.константы.insert(константа.имя.текст.clone(), СкомпКонстанта { синтаксис: константа, значение }) {
                        unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючВкл => {
                    // СДЕЛАТЬ: расхардкодить пути поиска модулей
                    let пути_поиска_модулей = &[".", "./модули"];
                    // СДЕЛАТЬ: отслеживать повторное включение модулей и игнорировать его.
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                    let mut существует = false;
                    for путь in пути_поиска_модулей {
                        let mut путь_к_файлу = PathBuf::new();
                        путь_к_файлу.push(путь);
                        путь_к_файлу.push(&имя.текст);
                        путь_к_файлу.set_extension("хуя");
                        if путь_к_файлу.exists() {
                            существует = true;
                            let содержимое = ::прочитать_содержимое_файла(&путь_к_файлу, Some(имя.лок.clone()))?;
                            let mut лекс = Лексер::новый(&путь_к_файлу, &содержимое);
                            self.скомпилировать_лексемы(&mut лекс)?;
                            break;
                        }
                    }
                    if !существует {
                        диагностика!(имя.лок, "ОШИБКА", "Не удалось найти модуль «{имя}».", имя = имя.текст);
                        return Err(());
                    }
                }
                ВидЛексемы::КлючБибл => {
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    self.пп.библиотеки.insert(имя.текст.clone(), self.пп.библиотеки.len());
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                }
                ВидЛексемы::Конец => break,
                _ => unreachable!(),
            }
        }

        Ok(())
    }

    pub fn завершить_компиляцию(&mut self) {
        for (_, СкомпПеременная{адрес, ..}) in self.имена.переменные.iter_mut() {
            *адрес += self.пп.иниц_данные.len();
        }

        for индекс in &self.пп.заплатки_неиниц_указателей {
            if let Some(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(указатель), .. }) = self.пп.код.get_mut(*индекс) {
                *указатель += self.пп.иниц_данные.len();
            } else {
                unreachable!("Ошибка в процессе сбора заплаток указателей на неинициализированные данные. Каждый индекс такой заплатки должен указывать на инструкцию ПротолкнутьУказатель");
            }
        }
    }
}
