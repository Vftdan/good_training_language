/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use std::path::PathBuf;
use синтаксис::*;
use диагностика::*;
use лексика::*;
use типизация::*;
use интерпретатор::РАЗМЕР_СЛОВА;

/// Инструкция промежуточного представления
#[derive(Debug, PartialEq)]
pub enum ВидИнструкции {
    Ноп,
    /// Протолкнуть целое значение на стек аргументов.
    ПротолкнутьЦел(usize),
    /// Протолкнуть указатель на данные.
    ///
    /// Эта инструкция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ПротолкнутьУказатель(usize), // СДЕЛАТЬ: по возможности, использовать u64 вместо usize для значений пп

    ВыделитьНаВторомСтеке(u64),
    ОсвободитьСоВторогоСтека(u64),
    ВершинаВторогоСтека(i32),

    СохранитьКадрВторогоСтека,
    ВосстановитьКадрВторогоСтека,
    КадрВторогоСтека(i32),

    АргументНаСтек,
    АргументСоСтека,

    Записать8,
    Записать32,
    Записать64,
    Прочитать32,
    Прочитать64,
    СкопироватьПамять,
    ЦелСложение,
    ЦелВычитание,
    ЦелУмножение,
    ЦелДеление,
    ЦелОстаток,
    ЦелМеньше,
    ЦелБольше,
    ЦелРавно,
    КонвертЦел64Вещ32,
    КонвертВещ32Цел64,
    Вещ32Умножение,
    Вещ32Деление,
    Вещ32Сложение,
    Вещ32Меньше,
    Вещ32Больше,
    Вещ32Инверт,
    ЛогОтрицание,
    БитИли,
    ПечатьСтроки,
    Ввод,
    Возврат,
    ВнутреннийВызов(usize),
    ВнешнийВызов{индекс: usize, арность: usize, результат: Option<Тип>},
    // СДЕЛАТЬ: инструкции изменения потока исполнения должны принимать относительное смещение.
    // Данный подход позволяет создавать легко перемещаемый код. Хотя, я не уверен, что это подойдет
    // для ВызватьВнутренююПроцедуру.
    //
    // Возможно имеет смысл пойти по пути BEAM и использовать ярлыки-инструкции.
    Прыжок(usize),
    УсловныйПрыжок(usize),
    СисВызов{ арность: usize },
}

pub struct Инструкция {
    pub лок: Лок,
    pub вид: ВидИнструкции,
}

#[derive(Clone)]
pub struct СкомпПеременная {
    pub имя: Лексема,
    pub тип: Тип,
    pub адрес: usize,
}

#[derive(Debug)]
pub struct СкомпПараметр {
    pub имя: Лексема,
    pub тип: Тип,
    pub смещение_от_кадра: i32,
}

#[derive(Debug)]
pub enum ТочкаВхода {
    Внутреняя { адрес: usize },
    Внешняя { индекс: usize },
}

#[derive(Clone, Debug)]
pub struct РезультатСкомпПроцедуры {
    тип: Тип,
    смещение_от_кадра: i32,
}

#[derive(Debug)]
pub struct СкомпПроцедура {
    pub имя: Лексема,
    pub параметры: Vec<СкомпПараметр>,
    pub результат: Option<РезультатСкомпПроцедуры>,
    pub точка_входа: ТочкаВхода,
}

#[derive(Debug)]
pub struct СкомпКонстанта {
    pub синтаксис: Константа,
    pub значение: usize,
}

/// Промежуточное Представление
#[derive(Default)]
pub struct ПП {
    pub код: Vec<Инструкция>,
    pub иниц_данные: Vec<u8>,
    pub размер_неиниц_данных: usize,
    pub заплатки_неиниц_указателей: Vec<usize>,
    pub строки: HashMap<String, usize>,
    pub внешние_символы: HashMap<String, usize>,
    pub библиотеки: HashMap<String, usize>,
}

impl ПП {
    pub fn вывалить(&self, точка_входа: usize) {
        println!("Инструкции ({количество} {инструкций}):",
                 количество = self.код.len(),
                 инструкций = ЧИСУЩ_ИНСТРУКЦИЙ.текст(self.код.len()));
        let ширина_столбца_индекса = self.код.len().to_string().len();
        let mut начало = 0;
        while начало < self.код.len() {
            let mut конец = начало;
            while конец < self.код.len() && self.код[начало].лок == self.код[конец].лок{
                конец += 1;
            }
            let Лок{путь_к_файлу, строка, столбец} = &self.код[начало].лок;
            println!("{путь_к_файлу}:{строка}:{столбец}: ", путь_к_файлу = путь_к_файлу.display());
            for индекс in начало..конец {
                print!("    {индекс:0>ширина_столбца_индекса$}: {вид:?}", вид = self.код[индекс].вид);
                if точка_входа == индекс {
                    print!(" <- точка входа");
                }
                println!();
            }
            начало = конец;
        }
        println!();
        // СДЕЛАТЬ: Показать где находятся адреса переменных в памяти
        println!("Инициализированные данные ({размер} {байт}):",
                 размер = self.иниц_данные.len(),
                 байт = ЧИСУЩ_БАЙТ.текст(self.иниц_данные.len()));
        const ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ: usize = 16;
        for строка in 0..self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ {
            let адрес = строка*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        let остаток = self.иниц_данные.len()%ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
        if остаток > 0 {
            let адрес = self.иниц_данные.len()/ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ*ШИРИНА_КОЛОНКИ_ИНИЦ_ДАННЫХ;
            print!("    {адрес:#08X}: ");
            let байты = &self.иниц_данные[адрес..адрес + остаток];
            for байт in байты {
                print!("{байт:#04X} ");
            }
            println!()
        }
        println!();
        println!("Размер неинициализированных данных:");
        println!("    {размер} {байт}",
                 размер = self.размер_неиниц_данных,
                 байт = ЧИСУЩ_БАЙТ.текст(self.размер_неиниц_данных))
    }
}

#[derive(Default)]
pub struct Имена {
    pub константы: HashMap<String, СкомпКонстанта>,
    pub процедуры: HashMap<String, СкомпПроцедура>,
    pub переменные: HashMap<String, СкомпПеременная>,
    pub структуры: HashMap<String, Структура>,
}

impl Имена {
    fn верифицировать_переопределение_имени(&self, имя: &Лексема) -> Результат<()> {
        if let Some(существующая_переменная) = self.переменные.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует переменная с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_процедура) = self.процедуры.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует процедура с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        if let Some(существующая_константа) = self.константы.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует константа с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_константа.синтаксис.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return Err(())
        }

        Ok(())
    }
}

#[derive(Default)]
pub struct Программа {
    pub пп: ПП,
    pub имена: Имена,
}

fn скомпилировать_выражение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, выражение: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    match выражение {
        Выражение::ЦелЧисло(лексема, число) => {
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(*число), лок: лексема.лок.clone() });
            Ok(Тип::Цел64)
        },
        Выражение::ВещЧисло(лексема, число) => {
            let число = u32::from_le_bytes(число.to_le_bytes()) as usize;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(число), лок: лексема.лок.clone() });
            Ok(Тип::Вещ32)
        },
        Выражение::Строка(строка) => {
            let (указатель, длинна) = if let Some(указатель) = пп.строки.get(&строка.текст) {
                (*указатель, строка.текст.len())
            } else {
                let указатель = пп.иниц_данные.len();
                let длинна = строка.текст.len();
                пп.иниц_данные.extend(строка.текст.as_bytes());
                пп.иниц_данные.push(0); // ЗАМЕТКА: нулл-терминатор на случае если мы захотим что-то передать в сишный код
                пп.строки.insert(строка.текст.clone(), указатель);
                (указатель, длинна)
            };
            let тип = Тип::Строка;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаВторомСтеке(тип.размер(&имена.структуры) as u64), лок: строка.лок.clone() });
            *временный_размер += тип.размер(&имена.структуры);

            // СДЕЛАТЬ: несколько много инструкций для компиляции простого строкового литерала
            // Может быть имеет смысл ввести сокращения для инструкций? Что-то типа Записать64НаСтеке(i32).

            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(длинна), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаВторогоСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: строка.лок.clone() });

            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(указатель), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаВторогоСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: строка.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: строка.лок.clone() });

            пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаВторогоСтека(0), лок: строка.лок.clone() });

            Ok(тип)
        }
        Выражение::Идент(лексема) => {
            if let Some(константа) = имена.константы.get(&лексема.текст) {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(константа.значение), лок: лексема.лок.clone() });
                return Ok(Тип::Цел64);
            }
            if let Some(параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == лексема.текст) {
                пп.код.push(Инструкция{ вид: ВидИнструкции::КадрВторогоСтека(параметр.смещение_от_кадра), лок: лексема.лок.clone() });
                if параметр.тип.примитивный() {
                    прочитать_примитивный_тип(&лексема.лок, &mut пп.код, параметр.тип.размер(&имена.структуры))?;
                }

                return Ok(параметр.тип.clone());
            }
            if let Some(переменная) = имена.переменные.get(&лексема.текст) {
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: лексема.лок.clone() });
                match переменная.тип {
                    Тип::Цел64 => {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: лексема.лок.clone()});
                        return Ok(переменная.тип.clone());
                    }
                    Тип::Вещ32 => {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать32, лок: лексема.лок.clone()});
                        return Ok(переменная.тип.clone());
                    }
                    _ => {
                        сделать!(&лексема.лок, "Чтение переменных тип «{тип}»", тип = переменная.тип.текст());
                        return Err(())
                    }
                }
            }
            диагностика!(&лексема.лок, "ОШИБКА",
                         "не существует ни констант, ни переменных с имением «{имя}»",
                         имя = &лексема.текст);
            Err(())
        }
        Выражение::Биноп {ключ, вид, левое, правое} => {
            match вид {
                ВидБинопа::Меньше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелМеньше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Меньше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(Тип::Лог)
                }
                ВидБинопа::Больше => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелБольше, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Больше, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Меньше для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(Тип::Лог)
                }
                ВидБинопа::Или => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(левое.лок(), &Тип::Лог, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Лог, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::БитИли, лок: ключ.лок.clone() });
                    Ok(Тип::Лог)
                }
                ВидБинопа::Сложение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Сложение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Сложение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Вычитание => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелВычитание, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Умножение => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Умножение, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Перемножение для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Деление => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    match левый_тип {
                        Тип::Цел64 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелДеление, лок: ключ.лок.clone() });
                        }
                        Тип::Вещ32 => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Деление, лок: ключ.лок.clone() });
                        }
                        _ => {
                            диагностика!(&ключ.лок, "ОШИБКА", "Деление для типов «{тип}» не поддерживается",
                                         тип = левый_тип.текст());
                            return Err(());
                        }
                    }
                    Ok(левый_тип)
                }
                ВидБинопа::Остаток => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    проверить_типы(левое.лок(), &Тип::Цел64, &левый_тип)?;
                    проверить_типы(правое.лок(), &Тип::Цел64, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелОстаток, лок: ключ.лок.clone() });
                    Ok(Тип::Цел64)
                }
                ВидБинопа::Равно => {
                    let левый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &левое, временный_размер)?;
                    let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, &правое, временный_размер)?;
                    if левый_тип != Тип::Цел64 {
                        сделать!(левое.лок(), "Сравнение типа «{тип}»", тип = левый_тип.текст());
                        return Err(())
                    }
                    проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелРавно, лок: ключ.лок.clone() });
                    Ok(Тип::Лог)
                }
                ВидБинопа::Как => {
                    let значение = левое;
                    let тип = правое;
                    let тип_цели = скомпилировать_тип(тип, &имена.константы)?;
                    let тип_значения = скомпилировать_выражение(пп, имена, текущая_процедура, &значение, временный_размер)?;

                    if тип_значения == тип_цели {
                        return Ok(тип_цели);
                    }

                    match (&тип_значения, &тип_цели) {
                        (Тип::Цел64, Тип::Цел8) => Ok(тип_цели),
                        (Тип::Цел64, Тип::Вещ32) => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертЦел64Вещ32, лок: ключ.лок.clone() });
                            Ok(тип_цели)
                        }
                        (Тип::Вещ32, Тип::Цел64) => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::КонвертВещ32Цел64, лок: ключ.лок.clone() });
                            Ok(тип_цели)
                        }
                        _ => {
                            сделать!(&ключ.лок, "Конвертация типа «{тип_значения}» в тип «{тип_цели}»",
                                     тип_значения = тип_значения.текст(),
                                     тип_цели = тип_цели.текст());
                            return Err(());
                        }
                    }
                }
            }
        }

        Выражение::УнарныйМинус {ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, &выражение, временный_размер)?;
            match тип {
                Тип::Вещ32 => {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::Вещ32Инверт, лок: ключ.лок.clone() });
                    Ok(тип)
                }
                _ => {
                    диагностика!(&ключ.лок, "ОШИБКА", "Тип «{тип}» не может быть отрицательным", тип = тип.текст());
                    Err(())
                }
            }
        }

        Выражение::Вызов {имя, аргументы} => {
            match имя.текст.as_str() {
                // СДЕЛАТЬ: не позволять переопределять процедуру интринсиков в пользовательском коде.
                "ввод" => {
                    let [массив] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 1;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };
                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Ввод параметров");
                            return Err(())
                        }
                        if let Some(переменная) = имена.переменные.get(&имя.текст) {
                            if let Тип::Массив{размер, тип_элемента} = &переменная.тип {
                                if **тип_элемента != Тип::Цел8 {
                                    диагностика!(&имя.лок, "ОШИБКА", "Ввод возможет только в массива элементов «{тип_элемента}»", тип_элемента = тип_элемента.текст());
                                    return Err(())
                                }

                                пп.заплатки_неиниц_указателей.push(пп.код.len());
                                // СДЕЛАТЬ: поменять местами аргументы по аналогии с ПечатьСтроки
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(*размер), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Ввод, лок: имя.лок.clone() });
                                return Ok(Тип::Цел64);
                            } else {
                                // СДЕЛАТЬ: было бы полезно читать ввод в срезы.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Ввод можно осуществлять только в массивы на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Ввод требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                "срез" => {
                    let [массив, начало_среза, размер_среза] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 3;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    if let Выражение::Идент(имя) = массив {
                        if let Some(_параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                            сделать!(&имя.лок, "Срезы параметров");
                            return Err(())
                        }
                        if let Some(переменная) = имена.переменные.get(&имя.текст) {
                            if let Тип::Массив{размер: _, тип_элемента} = &переменная.тип {
                                let тип_среза = Тип::Срез {
                                    тип_элемента: тип_элемента.clone()
                                };

                                let тип_размера_среза = скомпилировать_выражение(пп, имена, текущая_процедура, &размер_среза, временный_размер)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел64, &тип_размера_среза)?;

                                пп.заплатки_неиниц_указателей.push(пп.код.len());
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });

                                let тип_начала = скомпилировать_выражение(пп, имена, текущая_процедура, &начало_среза, временный_размер)?;
                                проверить_типы(&размер_среза.лок(), &Тип::Цел64, &тип_начала)?;

                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });

                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаВторомСтеке(тип_среза.размер(&имена.структуры) as u64), лок: имя.лок.clone() });
                                *временный_размер += тип_среза.размер(&имена.структуры);
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаВторогоСтека(СРЕЗ_АДРЕС_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаВторогоСтека(СРЕЗ_РАЗМЕР_СМЕЩЕНИЕ as i32), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: имя.лок.clone() });

                                пп.код.push(Инструкция{ вид: ВидИнструкции::ВершинаВторогоСтека(0), лок: имя.лок.clone() });

                                return Ok(тип_среза);
                            } else {
                                // СДЕЛАТЬ: было бы полезно иметь срезы срезов.
                                диагностика!(&имя.лок, "ОШИБКА",
                                             "Переменная «{имя}» не является массивом. Срезы возможны только для массивов на данный момент.",
                                             имя = &имя.текст);
                                return Err(())
                            }
                        }

                        диагностика!(&имя.лок, "ОШИБКА",
                                     "не существует ни параметров, ни переменных с имением «{имя}»",
                                     имя = &имя.текст);
                        Err(())
                    } else {
                        // СДЕЛАТЬ: возможно данные аргумент должен быть передан по ссылке.
                        // Но мы пока не имеем подобного механизма.
                        диагностика!(&имя.лок, "ОШИБКА", "Срез требует имя массива в качестве первого аргумента");
                        Err(())
                    }
                }
                "сисвызов" => {
                    if аргументы.len() == 0 {
                        сделать!(&имя.лок, "Диагностика некорректной арности «сисвызов»-ов");
                        return Err(());
                    }
                    let арность = аргументы.len() - 1;

                    for аргумент in аргументы {
                        let тип_аргумента = скомпилировать_выражение(пп, имена, текущая_процедура, аргумент, временный_размер)?;
                        проверить_типы(&аргумент.лок(), &Тип::Цел64, &тип_аргумента)?;
                    }

                    пп.код.push(Инструкция{ вид: ВидИнструкции::СисВызов{арность}, лок: имя.лок.clone() });
                    Ok(Тип::Цел64)
                }
                "адрес" => {
                    let [срез] = аргументы.as_slice() else {
                        let количество_аргументов = аргументы.len();
                        let количество_параметров = 1;
                        диагностика!(&имя.лок, "ОШИБКА",
                                     "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                     параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                     аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                        return Err(());
                    };

                    let тип_среза = скомпилировать_выражение(пп, имена, текущая_процедура, &срез, временный_размер)?;
                    match тип_среза {
                        Тип::Срез{..} | Тип::Строка => {
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(СРЕЗ_АДРЕС_СМЕЩЕНИЕ), лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone()});
                            пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: имя.лок.clone()});
                            Ok(Тип::Цел64)
                        }
                        _ => {
                            диагностика!(&срез.лок(), "ОШИБКА", "Несоответствие типов данных. Ожидался тип «строка», либо «срез», но повстречался тип «{действительный}»",
                                         действительный = тип_среза.текст());
                            Err(())
                        }
                    }
                }
                _ => {
                    if let Some(процедура) = имена.процедуры.get(&имя.текст) {
                        // СДЕЛАТЬ: дупликация кода между компиляцией вызова процедур как выражений и как утверждений.

                        let количество_аргументов = аргументы.len();
                        let количество_параметров = процедура.параметры.len();
                        if количество_аргументов != количество_параметров {
                            диагностика!(&имя.лок, "ОШИБКА",
                                         "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                         параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                         аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                            return Err(());
                        }

                        for (параметр, аргумент) in процедура.параметры.iter().zip(аргументы.iter()).rev() {
                            let тип = скомпилировать_выражение(пп, имена, процедура, аргумент, временный_размер)?;
                            проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                        }
                        вызвать_процедуру(имя.лок.clone(), имена, &процедура, &mut пп.код, временный_размер)?;

                        if let Some(результат) = &процедура.результат {
                            return Ok(результат.тип.clone())
                        } else {
                            диагностика!(&имя.лок, "ОШИБКА", "Данная процедура ничего не возвращает. Её нельзя использовать как выражение. Только как утверждение.");
                            return Err(())
                        }
                    }

                    if let Some(переменная) = имена.переменные.get(&имя.текст) {
                        match &переменная.тип {
                            Тип::Массив{тип_элемента, ..} => {
                                let [индекс] = &аргументы[..] else {
                                    диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.len());
                                    return Err(());
                                };

                                пп.заплатки_неиниц_указателей.push(пп.код.len());
                                пп.код.push(Инструкция{
                                    вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес),
                                    лок: имя.лок.clone()
                                });

                                // СДЕЛАТЬ: проверку входа за границы массива.

                                let тип_индекса = скомпилировать_выражение(пп, имена, текущая_процедура, &индекс, временный_размер)?;
                                проверить_типы(&индекс.лок(), &Тип::Цел64, &тип_индекса)?;
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });
                                match **тип_элемента {
                                    Тип::Вещ32 => пп.код.push(Инструкция{ вид: ВидИнструкции::Прочитать32, лок: имя.лок.clone() }),
                                    _ => {
                                        сделать!(&имя.лок, "Мы пока не умеем читать массивы элементов типа «{тип}»", тип = тип_элемента.текст());
                                        return Err(());
                                    }
                                }

                                return Ok(*тип_элемента.clone())
                            }
                            Тип::Срез{..} => {
                                сделать!(&имя.лок, "Индексация срезов");
                                return Err(())
                            }
                            _ => {
                                диагностика!(&имя.лок, "ОШИБКА", "Невозможно индексировать тип «{тип}»", тип = переменная.тип.текст());
                                return Err(())
                            }
                        }
                    }

                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестная имя «{имя}»", имя = имя.текст);
                    Err(())
                }
            }
        }

        Выражение::Отрицание{ключ, выражение} => {
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, выражение, временный_размер)?;
            проверить_типы(&выражение.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            Ok(Тип::Лог)
        }
    }
}

fn достать_и_проверить_процедуру_печати<'ы>(имена: &'ы Имена, имя_принтера: &str, тип: &Тип, лок: &Лок) -> Результат<&'ы СкомпПроцедура> {
    if let Some(процедура) = имена.процедуры.get(имя_принтера) {
        let арность = 1;
        let [параметр] = процедура.параметры.as_slice() else {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает {число_параметров}", число_параметров = процедура.параметры.len());
            return Err(());
        };
        if параметр.тип != *тип {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она должна принимать {арность} {параметров} типа «{тип}»", тип = тип.текст(), параметров = ЧИСУЩ_ПАРАМЕТР.текст(арность));
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она принимает тип «{тип}»", тип = параметр.тип.текст());
            return Err(());
        }
        if let Some(результат) = &процедура.результат {
            диагностика!(лок, "ОШИБКА", "Процедура «{имя_принтера}» ответственная за печать данного аргумента типа «{тип}» имеет некорректную сигнатуру. Она не должна возвращать никаких результатов", тип = тип.текст());
            диагностика!(&процедура.имя.лок, "ИНФО", "Но по факту, она возвращает тип «{тип}»", тип = результат.тип.текст());
            return Err(());
        }

        Ok(процедура)
    } else {
        диагностика!(лок, "ОШИБКА", "Чтобы печатать значения типа «{тип}», нужно чтобы где-нибудь была определена процедура с именем «{имя_принтера}», которая принимает один аргумент типа «{тип}» и печатает его. Мы не смогли найти определение такой процедуры. Обычно все нужные процедуры печати определены в модуле «прелюдия». Возможно мы не смогли его загрузить.", тип = тип.текст());
        Err(())
    }
}

fn вызвать_процедуру(лок: Лок, имена: &Имена, процедура: &СкомпПроцедура, код: &mut Vec<Инструкция>, временный_размер: &mut usize) -> Результат<()> {
    match &процедура.точка_входа {
        &ТочкаВхода::Внутреняя{адрес} => {
            код.push(Инструкция {
                вид: ВидИнструкции::ВнутреннийВызов(адрес),
                лок: лок.clone(),
            });
            if let Some(результат) = &процедура.результат {
                if !результат.тип.примитивный() {
                    *временный_размер += результат.тип.размер(&имена.структуры);
                }
            }
        },
        &ТочкаВхода::Внешняя{индекс} => {
            for параметр in &процедура.параметры {
                if параметр.тип != Тип::Цел64 {
                    сделать!(&лок, "Вызов внешней процедуры с параметрами типа «{тип}»", тип = параметр.тип.текст());
                    return Err(())
                }
            }

            код.push(Инструкция {
                вид: ВидИнструкции::ВнешнийВызов{
                    индекс,
                    арность: процедура.параметры.len(),
                    результат: процедура.результат.clone().map(|результат| результат.тип),
                },
                лок,
            });
        },
    }
    Ok(())
}

/// Левое выражение - это выражение по левой стороне от присваивания:
///
/// <левое> := <правое>;
///
/// Особенность левых выражений в том, что они являются ссылками.
fn скомпилировать_левое_выражение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, выражение: &Выражение, временный_размер: &mut usize) -> Результат<Тип> {
    match выражение {
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не может находиться в левой части присваивания");
            Err(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не может находиться в левой части присваивания");
            Err(())
        }
        Выражение::Строка(лексема) => {
            // А мы точно хотим разрешать подобные вещи?
            сделать!(&лексема.лок, "Присваивание строковых литералов");
            Err(())
        }
        Выражение::Идент(имя) => {
            if let Some(параметр) = текущая_процедура.параметры.iter().find(|параметр| параметр.имя.текст == имя.текст) {
                пп.код.push(Инструкция{ вид: ВидИнструкции::КадрВторогоСтека(параметр.смещение_от_кадра), лок: имя.лок.clone() });
                return Ok(параметр.тип.clone());
            }

            if let Some(переменная) = имена.переменные.get(имя.текст.as_str()) {
                пп.заплатки_неиниц_указателей.push(пп.код.len());
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });
                return Ok(переменная.тип.clone())
            }

            диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = имя.текст);
            Err(())
        }
        Выражение::Вызов{имя, аргументы} => {
            let переменная = if let Some(переменная) = имена.переменные.get(&имя.текст) {
                переменная
            } else {
                // СДЕЛАТЬ: Капитализировать все сообщения диагностики и заверщить их точкой в конце.
                диагностика!(&имя.лок, "ОШИБКА", "Переменной с именем «{имя}» не существует.", имя = имя.текст);
                return Err(());
            };

            let тип_элемента = if let Тип::Массив{тип_элемента, размер: _} = переменная.тип.clone() {
                тип_элемента
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Переменная с именем «{имя}» не является массивом. Её нельзя индексировать.", имя = имя.текст);
                return Err(());
            };

            if аргументы.len() != 1 {
                диагностика!(&имя.лок, "ОШИБКА", "Некорректная размерность массива. Ожидался 1 индекс, но повстречалось {ранк}", ранк = аргументы.len());
                return Err(());
            };
            let индекс = &аргументы[0];

            пп.заплатки_неиниц_указателей.push(пп.код.len());
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(переменная.адрес), лок: имя.лок.clone() });

            // СДЕЛАТЬ: проверку входа за границы массива.

            let тип_индекса = скомпилировать_выражение(пп, имена, текущая_процедура, индекс, временный_размер)?;
            проверить_типы(&индекс.лок(), &Тип::Цел64, &тип_индекса)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(тип_элемента.размер(&имена.структуры)), лок: имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелУмножение, лок: имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЦелСложение, лок: имя.лок.clone() });

            Ok(*тип_элемента.clone())
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Унарный минус не может находится в левой части присваивания");
            Err(())
        }
        Выражение::Биноп{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Бинарные операции не могут находится в левой части присваивния");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не может находится в левой части присваивния");
            Err(())
        }
    }
}

fn скомпилировать_утверждение(пп: &mut ПП, имена: &Имена, текущая_процедура: &СкомпПроцедура, утверждение: &Утверждение, отложенные_возвраты: &mut Vec<usize>) -> Результат<()> {
    match утверждение {
        Утверждение::Присваивание{ключ, левое, правое} => {
            let mut временный_размер = 0;
            let правый_тип = скомпилировать_выражение(пп, имена, текущая_процедура, правое, &mut временный_размер)?;
            let левый_тип = скомпилировать_левое_выражение(пп, имена, текущая_процедура, левое, &mut временный_размер)?;
            проверить_типы(правое.лок(), &левый_тип, &правый_тип)?;
            if левый_тип.примитивный() {
                записать_примитивный_тип(&ключ.лок, &mut пп.код, левый_тип.размер(&имена.структуры))?;
            } else {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(левый_тип.размер(&имена.структуры)), лок: ключ.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::СкопироватьПамять, лок: ключ.лок.clone() });
            }
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(временный_размер as u64), лок: ключ.лок.clone() })
            }
            Ok(())
        }
        Утверждение::Выражение{выражение} => {
            match выражение {
                Выражение::Вызов{имя, аргументы} => {
                    match имя.текст.as_str() {
                        // СДЕЛАТЬ: не позволять переопределять процедуру «печать» в пользовательском коде.
                        "печать" => {
                            let mut временный_размер = 0;
                            for арг in аргументы {
                                let тип = скомпилировать_выражение(пп, имена, текущая_процедура, &арг, &mut временный_размер)?;
                                match тип {
                                    Тип::Строка => {
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: арг.лок().clone() })
                                    }
                                    Тип::Цел64 => {
                                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_цел", &тип, &арг.лок())?;
                                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                                    }
                                    Тип::Лог => {
                                        let процедура = достать_и_проверить_процедуру_печати(имена, "печать_лог", &тип, &арг.лок())?;
                                        вызвать_процедуру(арг.лок().clone(), имена, процедура, &mut пп.код, &mut временный_размер)?;
                                    }
                                    Тип::Срез{тип_элемента} => {
                                        if *тип_элемента != Тип::Цел8 {
                                            сделать!(арг.лок(), "Печать срезов элементов типа «{тип}» пока не поддерживается",
                                                     тип = тип_элемента.текст());
                                            return Err(())
                                        }
                                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПечатьСтроки, лок: имя.лок.clone() });
                                    }
                                    _ => {
                                        сделать!(арг.лок(), "печать переменных типа «{тип}»", тип = тип.текст());
                                        return Err(())
                                    }
                                }
                            }
                            if временный_размер > 0 {
                                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(временный_размер as u64), лок: имя.лок.clone() });
                            }
                            Ok(())
                        },
                        _ => {
                            if let Some(вызываемая_процедура) = имена.процедуры.get(&имя.текст) {
                                if вызываемая_процедура.результат.is_some() {
                                    сделать!(&вызываемая_процедура.имя.лок, "Вызов процедур возвращающих значение в контексте утверждения");
                                    // За ними нужно подчищать стек аргументов.
                                    return Err(())
                                }

                                let количество_аргументов = аргументы.len();
                                let количество_параметров = вызываемая_процедура.параметры.len();
                                if количество_аргументов != количество_параметров {
                                    диагностика!(&имя.лок, "ОШИБКА",
                                                 "Неверное количество аргументов вызова процедуры. Процедура принимает {количество_параметров} {параметров}, но в данном вызове предоставлено лишь {количество_аргументов} {аргументов}.",
                                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                                    return Err(());
                                }

                                let mut временный_размер = 0;
                                for (параметр, аргумент) in вызываемая_процедура.параметры.iter().zip(аргументы.iter()).rev() {
                                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, аргумент, &mut временный_размер)?;
                                    проверить_типы(&аргумент.лок(), &параметр.тип, &тип)?;
                                    match параметр.тип {
                                        Тип::Цел64 | Тип::Лог => {}
                                        _ => {
                                            сделать!(&параметр.имя.лок, "Определение локальных переменных типа «{тип:?}»", тип = параметр.тип);
                                            return Err(())
                                        }
                                    }
                                }
                                вызвать_процедуру(имя.лок.clone(), имена, вызываемая_процедура, &mut пп.код, &mut временный_размер)?;
                                if временный_размер > 0 {
                                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(временный_размер as u64), лок: имя.лок.clone() });
                                }
                                Ok(())
                            } else {
                                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                                Err(())
                            }
                        }
                    }
                }
                _ => {
                    сделать!(выражение.лок(), "Выражения в контексте утверждений");
                    Err(())
                }
            }
        }
        Утверждение::Если{ключ, условие, тело, иначе} => {
            let mut временный_размер = 0;
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, &условие, &mut временный_размер)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(временный_размер as u64), лок: ключ.лок.clone() });
            }
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
            for утверждение in тело.iter() {
                скомпилировать_утверждение(пп, имена, текущая_процедура, утверждение, отложенные_возвраты)?;
            }

            if иначе.len() == 0 {
                let точка_выхода = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            } else {
                let точка_конца_тела = пп.код.len();
                пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });

                let точка_иначе = пп.код.len();
                пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_иначе);

                for утверждение in иначе.iter() {
                    скомпилировать_утверждение(пп, имена, текущая_процедура, утверждение, отложенные_возвраты)?;
                }

                let точка_выхода = пп.код.len();
                пп.код[точка_конца_тела].вид = ВидИнструкции::Прыжок(точка_выхода);
            }
            Ok(())
        }
        Утверждение::Вернуть{ключ, выражение} => {
            if let Some(выражение) = выражение {
                if let Some(результат) = &текущая_процедура.результат {
                    let mut временный_размер = 0;
                    let тип = скомпилировать_выражение(пп, имена, текущая_процедура, &выражение, &mut временный_размер)?;
                    проверить_типы(&выражение.лок(), &результат.тип, &тип)?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::КадрВторогоСтека(результат.смещение_от_кадра), лок: ключ.лок.clone() });
                    if тип.примитивный() {
                        записать_примитивный_тип(&ключ.лок, &mut пп.код, тип.размер(&имена.структуры))?;
                    } else {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(тип.размер(&имена.структуры)), лок: ключ.лок.clone() });
                        пп.код.push(Инструкция{ вид: ВидИнструкции::СкопироватьПамять, лок: ключ.лок.clone() });
                    }
                    if временный_размер > 0 {
                        пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(временный_размер as u64), лок: выражение.лок().clone() });
                    }
                } else {
                    диагностика!(выражение.лок(), "ОШИБКА", "Процедура не возвращает никаких значений");
                    return Err(());
                }
            } else {
                if let Some(результат) = &текущая_процедура.результат {
                    диагностика!(&ключ.лок, "ОШИБКА", "Процедура возвращает значение типа «{тип}»", тип = результат.тип.текст());
                    return Err(());
                }
            }
            отложенные_возвраты.push(пп.код.len());
            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(0), лок: ключ.лок.clone() });
            Ok(())
        }
        Утверждение::Пока{ключ, условие, тело} => {
            let точка_условия = пп.код.len();
            let mut временный_размер = 0;
            let тип = скомпилировать_выражение(пп, имена, текущая_процедура, &условие, &mut временный_размер)?;
            проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
            пп.код.push(Инструкция{ вид: ВидИнструкции::ЛогОтрицание, лок: ключ.лок.clone() });
            if временный_размер > 0 {
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(временный_размер as u64), лок: ключ.лок.clone() });
            }
            let точка_условного_прыжка = пп.код.len();
            пп.код.push(Инструкция{ вид: ВидИнструкции::Ноп, лок: ключ.лок.clone() });
            for утверждение in тело.iter() {
                скомпилировать_утверждение(пп, имена, текущая_процедура, утверждение, отложенные_возвраты)?;
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::Прыжок(точка_условия), лок: ключ.лок.clone() });
            let точка_выхода = пп.код.len();
            пп.код[точка_условного_прыжка].вид = ВидИнструкции::УсловныйПрыжок(точка_выхода);
            Ok(())
        }
    }
}

fn выравнять_размер_по_слову(размер: usize) -> usize {
    (размер + РАЗМЕР_СЛОВА - 1)/РАЗМЕР_СЛОВА*РАЗМЕР_СЛОВА
}

fn записать_примитивный_тип(лок: &Лок, код: &mut Vec<Инструкция>, размер: usize) -> Результат<()> {
    match размер {
        1 => код.push(Инструкция{ вид: ВидИнструкции::Записать8, лок: лок.clone() }),
        2 => {
            сделать!(лок, "Запись размером в 16 бит");
            return Err(());
        }
        4 => код.push(Инструкция{ вид: ВидИнструкции::Записать32, лок: лок.clone() }),
        8 => код.push(Инструкция{ вид: ВидИнструкции::Записать64, лок: лок.clone() }),
        размер => unreachable!("Примитивных типов размера {} нет", размер),
    }
    Ok(())
}

fn прочитать_примитивный_тип(лок: &Лок, код: &mut Vec<Инструкция>, размер: usize) -> Результат<()> {
    match размер {
        1 => {
            сделать!(лок, "Чтение размером в 8 бит");
            return Err(());
        }
        2 => {
            сделать!(лок, "Чтение размером в 16 бит");
            return Err(());
        }
        4 => код.push(Инструкция{ вид: ВидИнструкции::Прочитать32, лок: лок.clone() }),
        8 => код.push(Инструкция{ вид: ВидИнструкции::Прочитать64, лок: лок.clone() }),
        размер => unreachable!("Примитивных типов размера {} нет", размер),
    }
    Ok(())
}


fn скомпилировать_процедуру(пп: &mut ПП, имена: &mut Имена, процедура: Процедура) -> Результат<()> {
    let mut параметры = Vec::new();
    let mut размер_параметров_на_стеке: usize = 0;

    for параметр in &процедура.параметры {
        let тип = скомпилировать_тип(&параметр.тип, &имена.константы)?;
        let скомп_параметр = СкомпПараметр {
            имя: параметр.имя.clone(),
            тип,
            смещение_от_кадра: размер_параметров_на_стеке as i32,
        };
        размер_параметров_на_стеке += выравнять_размер_по_слову(скомп_параметр.тип.размер(&имена.структуры));
        параметры.push(скомп_параметр);
    }
    let результат = if let Some(тип) = процедура.тип_результата {
        let результат = РезультатСкомпПроцедуры {
            тип: скомпилировать_тип(&тип, &имена.константы)?,
            смещение_от_кадра: размер_параметров_на_стеке as i32,
        };
        размер_параметров_на_стеке += выравнять_размер_по_слову(результат.тип.размер(&имена.структуры));
        Some(результат)
    } else {
        None
    };
    match процедура.тело {
        ТелоПроцедуры::Внутренее{блок} => {
            let адрес = пп.код.len();
            let скомп_процедура = СкомпПроцедура{
                имя: процедура.имя.clone(),
                параметры,
                точка_входа: ТочкаВхода::Внутреняя{адрес},
                результат,
            };

            if let Some(_) = имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }

            let скомп_процедура = имена.процедуры.get(&процедура.имя.текст).unwrap();

            // СДЕЛАТЬ: Если размер_параметров_на_стеке равен 0, то, наверное, не имеет никакого смысла вообще включать данную инструкцию
            // Тоже самое можно сказать и про противоположную инструкцию ОсвободитьСоВторогоСтека.
            пп.код.push(Инструкция{ вид: ВидИнструкции::ВыделитьНаВторомСтеке(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::СохранитьКадрВторогоСтека, лок: процедура.имя.лок.clone() });
            пп.код.push(Инструкция{ вид: ВидИнструкции::АргументНаСтек, лок: процедура.имя.лок.clone() }); // сохраняем адрес возврата на второй стек
            for параметр in скомп_процедура.параметры.iter() {
                пп.код.push(Инструкция{ вид: ВидИнструкции::КадрВторогоСтека(параметр.смещение_от_кадра), лок: процедура.имя.лок.clone() });
                if параметр.тип.примитивный() {
                    записать_примитивный_тип(&процедура.имя.лок, &mut пп.код, параметр.тип.размер(&имена.структуры))?;
                } else {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ПротолкнутьЦел(параметр.тип.размер(&имена.структуры)), лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::СкопироватьПамять, лок: процедура.имя.лок.clone() });
                }
            }
            let mut отложенные_возвраты = Vec::new();
            for утверждение in &блок {
                скомпилировать_утверждение(пп, имена, &скомп_процедура, утверждение, &mut отложенные_возвраты)?;
            }
            let конец_процедуры = пп.код.len();
            for адрес in отложенные_возвраты {
                let инструкция = пп.код.get_mut(адрес).expect("отложенные возвраты из процедуры: некорретный адрес");
                assert!(инструкция.вид == ВидИнструкции::Прыжок(0), "отложенные возвраты из процедуры: некорректная инструкция: {:?}", инструкция.вид);
                инструкция.вид = ВидИнструкции::Прыжок(конец_процедуры);
            }
            if let Some(результат) = &скомп_процедура.результат {
                пп.код.push(Инструкция{ вид: ВидИнструкции::КадрВторогоСтека(результат.смещение_от_кадра), лок: процедура.имя.лок.clone() });
                if результат.тип.примитивный() {
                    прочитать_примитивный_тип(&процедура.имя.лок, &mut пп.код, результат.тип.размер(&имена.структуры))?;
                    пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадрВторогоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
                } else {
                    пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадрВторогоСтека, лок: процедура.имя.лок.clone() });
                    пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(размер_параметров_на_стеке as u64 - результат.тип.размер(&имена.структуры) as u64), лок: процедура.имя.лок.clone() });
                }
            } else {
                пп.код.push(Инструкция{ вид: ВидИнструкции::АргументСоСтека, лок: процедура.имя.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ВосстановитьКадрВторогоСтека, лок: процедура.имя.лок.clone() });
                пп.код.push(Инструкция{ вид: ВидИнструкции::ОсвободитьСоВторогоСтека(размер_параметров_на_стеке as u64), лок: процедура.имя.лок.clone() });
            }
            пп.код.push(Инструкция{ вид: ВидИнструкции::Возврат, лок: процедура.имя.лок.clone() });
            Ok(())
        }
        ТелоПроцедуры::Внешнее{символ} => {
            let индекс = пп.внешние_символы.len();
            let индекс = *пп.внешние_символы.entry(символ.текст).or_insert(индекс);
            let скомп_процедура = СкомпПроцедура{
                имя: процедура.имя,
                параметры,
                точка_входа: ТочкаВхода::Внешняя{индекс},
                результат,
            };
            if let Some(_) = имена.процедуры.insert(скомп_процедура.имя.текст.clone(), скомп_процедура) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }
            Ok(())
        }
    }
}

fn интерпретировать_выражение_константы(константы: &HashMap<String, СкомпКонстанта>, выражение: &Выражение) -> Результат<usize> {
    match выражение {
        &Выражение::ЦелЧисло(_, число) => Ok(число),
        Выражение::ВещЧисло(лексема, _) => {
            сделать!(&лексема.лок, "вещественные константы");
            Err(())
        },
        Выражение::Строка(строка) => {
            сделать!(&строка.лок, "строковые константы");
            Err(())
        }
        Выражение::Идент(имя) => {
            if let Some(константа) = константы.get(имя.текст.as_str()) {
                Ok(константа.значение)
            } else {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, вид, левое, правое, ..} => {
            let левое_значение = интерпретировать_выражение_константы(константы, левое)?;
            let правое_значение = интерпретировать_выражение_константы(константы, правое)?;
            match вид {
                ВидБинопа::Равно | ВидБинопа::Меньше | ВидБинопа::Больше | ВидБинопа::Или => {
                    сделать!(&ключ.лок, "булевые константы");
                    Err(())
                },
                ВидБинопа::Сложение => {
                    Ok(левое_значение + правое_значение)
                }
                ВидБинопа::Вычитание => {
                    Ok(левое_значение - правое_значение)
                }
                ВидБинопа::Умножение => {
                    Ok(левое_значение * правое_значение)
                }
                ВидБинопа::Деление => {
                    Ok(левое_значение / правое_значение)
                }
                ВидБинопа::Остаток => {
                    Ok(левое_значение % правое_значение)
                }
                ВидБинопа::Как => {
                    сделать!(&ключ.лок, "Мы пока что вообще не имеем типов в константах");
                    Err(())
                }
            }
        }
        Выражение::УнарныйМинус {ключ, выражение: _} => {
            сделать!(&ключ.лок, "константы пока что не могу быть отрицательными");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            сделать!(&ключ.лок, "булевые константы");
            Err(())
        }
        Выражение::Вызов{имя, ..} => {
            сделать!(&имя.лок, "вызов функции в константном контексте");
            Err(())
        }
    }
}

fn скомпилировать_тип(тип: &Выражение, константы: &HashMap<String, СкомпКонстанта>) -> Результат<Тип> {
    match тип {
        Выражение::ЦелЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Целое число не является являться типом");
            Err(())
        }
        Выражение::ВещЧисло(лексема, _) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Вещественное число не является являться типом");
            Err(())
        }
        Выражение::Строка(лексема) => {
            диагностика!(&лексема.лок, "ОШИБКА", "Строка не является являться типом");
            Err(())
        }
        Выражение::Идент(лексема) => match лексема.текст.as_str() {
            "цел" | "цел64" => Ok(Тип::Цел64),
            "цел8" => Ok(Тип::Цел8),
            "вещ" | "вещ32" => Ok(Тип::Вещ32),
            "строка" => Ok(Тип::Строка),
            "лог" => Ok(Тип::Лог),
            _ => {
                диагностика!(&лексема.лок, "ОШИБКА", "Неизвестный тип «{тип}»", тип = лексема.текст);
                Err(())
            }
        }
        Выражение::Вызов{имя, аргументы} => match имя.текст.as_str() {
            "массив" => {
                let [размер, тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 2;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let размер = интерпретировать_выражение_константы(константы, &размер)?;
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, константы)?);
                Ok(Тип::Массив{размер, тип_элемента})
            }
            "срез" => {
                let [тип_элемента] = аргументы.as_slice() else {
                    let количество_параметров = 1;
                    let количество_аргументов = аргументы.len();
                    диагностика!(&имя.лок, "ОШИБКА",
                                 "Неверное количество аргументов параметризированного типа. Тип «{имя}» принимает {количество_параметров} {параметров}, но предоставлено лишь {количество_аргументов} {аргументов}.",
                                 имя = имя.текст,
                                 параметров = ЧИСУЩ_ПАРАМЕТР.текст(количество_параметров),
                                 аргументов = ЧИСУЩ_АРГУМЕНТ.текст(количество_аргументов));
                    return Err(())
                };
                let тип_элемента = Box::new(скомпилировать_тип(&тип_элемента, константы)?);
                Ok(Тип::Срез{тип_элемента})
            }
            _ => {
                диагностика!(&имя.лок, "ОШИБКА", "Неизвестный параметризированный тип «{тип}»", тип = имя.текст);
                Err(())
            }
        }
        Выражение::Биноп{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные бинарные операции не поддерживаются в типах");
            Err(())
        }
        Выражение::УнарныйМинус{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Подобные унарные операции не поддерживаются в типах");
            Err(())
        }
        Выражение::Отрицание{ключ, ..} => {
            диагностика!(&ключ.лок, "ОШИБКА", "Отрицание не поддерживается в типах");
            // Хотя, это довольно таки интересна идея. Тип «не цел». Любой тип, кроме целого...
            Err(())
        }
    }
}

impl Программа {
    pub fn скомпилировать_лексемы(&mut self, лекс: &mut Лексер) -> Результат<()> {
        loop {
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::КлючПер,
                ВидЛексемы::КлючПро,
                ВидЛексемы::КлючКонст,
                ВидЛексемы::КлючВкл,
                ВидЛексемы::КлючБибл,
                ВидЛексемы::Конец,
            ])?;
            match ключ.вид {
                ВидЛексемы::КлючПер => {
                    let синтаксис = Переменная::разобрать(лекс)?;
                    let имя = синтаксис.имя;
                    self.имена.верифицировать_переопределение_имени(&имя)?;
                    let тип = скомпилировать_тип(&синтаксис.тип, &self.имена.константы)?;
                    let адрес = self.пп.размер_неиниц_данных;
                    self.пп.размер_неиниц_данных += тип.размер(&self.имена.структуры);
                    if let Some(_) = self.имена.переменные.insert(имя.текст.clone(), СкомпПеременная {имя, тип, адрес}) {
                        unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючПро => {
                    let процедура = Процедура::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&процедура.имя)?;
                    скомпилировать_процедуру(&mut self.пп, &mut self.имена, процедура)?;
                }
                ВидЛексемы::КлючКонст => {
                    let константа = Константа::разобрать(лекс)?;
                    self.имена.верифицировать_переопределение_имени(&константа.имя)?;
                    let значение = интерпретировать_выражение_константы(&self.имена.константы, &константа.выражение)?;
                    if let Some(_) = self.имена.константы.insert(константа.имя.текст.clone(), СкомпКонстанта { синтаксис: константа, значение }) {
                        unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
                    }
                }
                ВидЛексемы::КлючВкл => {
                    // СДЕЛАТЬ: расхардкодить пути поиска модулей
                    let пути_поиска_модулей = &[".", "./модули"];
                    // СДЕЛАТЬ: отслеживать повторное включение модулей и игнорировать его.
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                    let mut существует = false;
                    for путь in пути_поиска_модулей {
                        let mut путь_к_файлу = PathBuf::new();
                        путь_к_файлу.push(путь);
                        путь_к_файлу.push(&имя.текст);
                        путь_к_файлу.set_extension("хуя");
                        if путь_к_файлу.exists() {
                            существует = true;
                            let содержимое = ::прочитать_содержимое_файла(&путь_к_файлу, Some(имя.лок.clone()))?;
                            let mut лекс = Лексер::новый(&путь_к_файлу, &содержимое);
                            self.скомпилировать_лексемы(&mut лекс)?;
                            break;
                        }
                    }
                    if !существует {
                        диагностика!(имя.лок, "ОШИБКА", "Не удалось найти модуль «{имя}».", имя = имя.текст);
                        return Err(());
                    }
                }
                ВидЛексемы::КлючБибл => {
                    let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
                    self.пп.библиотеки.insert(имя.текст.clone(), self.пп.библиотеки.len());
                    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                }
                ВидЛексемы::Конец => break,
                _ => unreachable!(),
            }
        }

        Ok(())
    }

    pub fn завершить_компиляцию(&mut self) {
        for (_, СкомпПеременная{адрес, ..}) in self.имена.переменные.iter_mut() {
            *адрес += self.пп.иниц_данные.len();
        }

        for индекс in &self.пп.заплатки_неиниц_указателей {
            if let Some(Инструкция{ вид: ВидИнструкции::ПротолкнутьУказатель(указатель), .. }) = self.пп.код.get_mut(*индекс) {
                *указатель += self.пп.иниц_данные.len();
            } else {
                unreachable!("Ошибка в процессе сбора заплаток указателей на неинициализированные данные. Каждый индекс такой заплатки должен указывать на инструкцию ПротолкнутьУказатель");
            }
        }
    }
}
