use super::Результат;
use диагностика::*;

#[derive(PartialEq, Debug, Clone)]
pub enum Тип {
    Цел1,
    Цел8,
    Строка,
    Лог,
    Массив { размер: usize, тип_элемента: Box<Тип> },
    Срез { тип_элемента: Box<Тип> },
}

impl Тип {
    pub fn текст(&self) -> String {
        match self {
            Тип::Цел1 => "цел(1)".to_string(),
            Тип::Цел8 => "цел(8)".to_string(),
            Тип::Строка => "строка".to_string(),
            Тип::Лог => "лог".to_string(),
            Тип::Массив {тип_элемента, размер} => format!("массив({размер}) {тип_элемента}", тип_элемента = тип_элемента.текст()),
            Тип::Срез {тип_элемента} => format!("срез {тип_элемента}", тип_элемента = тип_элемента.текст()),
        }
    }

    pub fn размер(&self) -> usize{
        match self {
            Тип::Цел1 => 1,
            Тип::Цел8 => 8,
            Тип::Строка => 16, // Два 64-х битных числа: указатель на начало и размер.
            Тип::Лог => 8,
            Тип::Массив {тип_элемента, размер} => тип_элемента.размер() * размер,
            Тип::Срез {..} => 16, // Два 64-х битных числа: указатель на начало и размер.
        }
    }
}

pub fn проверить_типы(лок: &Лок, ожидаемый_тип: &Тип, действительный_тип: &Тип) -> Результат<()> {
    if ожидаемый_тип == действительный_тип {
        Ok(())
    } else {
        диагностика!(лок, "ОШИБКА", "Несоответствие типов данных. Ожидался тип «{ожидаемый}», но повстречался тип «{действительный}»",
                     ожидаемый = ожидаемый_тип.текст(),
                     действительный = действительный_тип.текст());
        Err(())
    }
}
