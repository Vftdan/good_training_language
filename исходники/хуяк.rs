use std::fs;
use std::env;
use std::io;
use std::process::ExitCode;
use std::path::Path;

#[path="./диагностика.rs"]
#[macro_use]
mod диагностика;
#[path="./лексика.rs"]
mod лексика;
#[path="./синтаксис.rs"]
mod синтаксис;
#[path="./пп.rs"]
mod пп;
#[path="./интерпретатор.rs"]
mod интерпретатор;
#[path="./эльф.rs"]
mod эльф;

use лексика::Лексер;
use пп::{Программа, Инструкция};
use интерпретатор::интерпретировать;

type Результат<Тэ> = Result<Тэ, ()>;

fn прочитать_содержание_файла(путь_к_файлу: &str) -> Результат<Vec<char>> {
    fs::read_to_string(путь_к_файлу)
        .map(|содержание| содержание.chars().collect())
        .map_err(|ошибка| {
            match ошибка.kind() {
                io::ErrorKind::NotFound => eprintln!("ОШИБКА: файл «{путь_к_файлу}» не найден"),
                // СДЕЛАТЬ: локализировать те ошибки, которые возможно.
                _ => eprintln!("ОШИБКА: не получилось прочитать файл «{путь_к_файлу}»: {ошибка}"),
            }
        })
}

struct Команда {
    имя: &'static str,
    описание: &'static str,
    запустить: fn(путь_к_файлу: &str) -> Результат<()>,
}

const КОМАНДЫ: &[Команда] = &[
    Команда {
        имя: "комп",
        описание: "Скомпилировать файл исходного кода в исполняемый файл для платформы Linux x86_64",
        запустить: |путь_к_файлу| {
            let содержание: Vec<char> = прочитать_содержание_файла(путь_к_файлу)?;
            let mut лекс = Лексер::новый(&путь_к_файлу, &содержание);
            let mut программа = Программа::default();
            программа.скомпилировать_модуль(&mut лекс)?;
            эльф::сгенерировать(&Path::new(&путь_к_файлу).with_extension(""), &программа)
        },
    },
    Команда {
        имя: "интер",
        описание: "Интерпретировать Промежуточное Представление скомпилированного файла",
        запустить: |путь_к_файлу| {
            let содержание: Vec<char> = прочитать_содержание_файла(путь_к_файлу)?;
            let mut лекс = Лексер::новый(&путь_к_файлу, &содержание);
            let mut программа = Программа::default();
            программа.скомпилировать_модуль(&mut лекс)?;
            интерпретировать(&программа, "главная")
        },
    },
    Команда {
        имя: "пп",
        описание: "Напечатать Промежуточное Представление скомпилированной программы",
        запустить: |путь_к_файлу| {
            let содержание: Vec<char> = прочитать_содержание_файла(путь_к_файлу)?;
            let mut лекс = Лексер::новый(&путь_к_файлу, &содержание);
            let mut программа = Программа::default();
            программа.скомпилировать_модуль(&mut лекс)?;
            программа.вывалить();
            Ok(())
        },
    },
    Команда {
        имя: "отлад",
        описание: "Отладочная команда. Абсолютно бесполезна для пользователя компилятора. Нужна только разработчику компиляторы, чтобы проверить что-нибудь.",
        запустить: |путь_к_файлу| {
            let mut программа = Программа::default();
            // СДЕЛАТЬ: может имеет смысл реализовать генерацию
            // бинарников из вот такого вот ассемблера ПП? Будет очень
            // удобно отлаживать генерацию машинного кода, когда
            // должный синтаксис еще не реализован.
            программа.код.push(Инструкция::ПротолкнутьЦелое(1));
            программа.код.push(Инструкция::ЛогОтрицание);
            программа.код.push(Инструкция::Возврат);
            программа.вывалить();
            эльф::сгенерировать(&Path::new(путь_к_файлу).with_extension(""), &программа)
        }
    }
];

fn главная() -> Результат<()> {
    let mut аргы = env::args();
    let программа = аргы.next().expect("программа");

    let пример = || {
        eprintln!("Пример: {программа} <команда> <файл.хуя>");
        eprintln!("Команды:");
        let ширина_столбца_имени = КОМАНДЫ.iter().map(|команда| {
            команда.имя.chars().count()
        }).max().unwrap_or(0);
        for Команда{имя, описание, ..} in КОМАНДЫ.iter() {
            // СДЕЛАТЬ: переносить длинные описания на новую строку.
            eprintln!("    {имя:ширина_столбца_имени$} - {описание}");
        }
    };

    let имя_команды = if let Some(имя_команды) = аргы.next() {
        имя_команды
    } else {
        пример();
        eprintln!("ОШИБКА: требуется команда!");
        return Err(());
    };

    if let Some(команда) = КОМАНДЫ.iter().find(|команда| имя_команды == команда.имя) {
        let путь_к_файлу = if let Some(путь_к_файлу) = аргы.next() {
            путь_к_файлу
        } else {
            пример();
            eprintln!("ОШИБКА: требуется файл с программой!");
            return Err(());
        };
        (команда.запустить)(&путь_к_файлу)
    } else {
        пример();
        eprintln!("ОШИБКА: неизвестная команда «{имя_команды}»");
        Err(())
    }
}

fn main() -> ExitCode {
    match главная() {
        Ok(()) => ExitCode::SUCCESS,
        Err(()) => ExitCode::FAILURE,
    }
}
