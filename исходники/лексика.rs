use super::диагностика::*;
use std::fmt::Write;

pub const ПРИСТАВКИ_ПРЕПИНАНИЙ: &[(&[char], ВидЛексемы)] = &[
    (&['('], ВидЛексемы::ОткрытаяСкобка),
    (&[')'], ВидЛексемы::ЗакрытаяСкобка),
    (&[';'], ВидЛексемы::ТочкаЗапятая),
    (&[','], ВидЛексемы::Запятая),
    (&['+'], ВидЛексемы::Плюс),
    (&[':', '='], ВидЛексемы::Присваивание),
];

pub const КЛЮЧЕВЫЕ_СЛОВА: &[(&str, ВидЛексемы)] = &[
    ("пер", ВидЛексемы::КлючПер),
    ("про", ВидЛексемы::КлючПро),
    ("нч", ВидЛексемы::КлючНч),
    ("кц", ВидЛексемы::КлючКц),
];

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ВидЛексемы {
    Конец,
    Идент,

    КлючПер,
    КлючПро,
    КлючНч,
    КлючКц,

    ОткрытаяСкобка,
    ЗакрытаяСкобка,
    ТочкаЗапятая,
    Запятая,
    Плюс,
    Присваивание,

    Число,
    Строка,
    НезавершённаяСтрока,
    Неизвестная,
}

impl ВидЛексемы {
    pub fn сущ(&self) -> Сущ {
        match self {
            ВидЛексемы::Конец               => Сущ{текст: "конец ввода",          род: Род::Муж},
            ВидЛексемы::Идент               => Сущ{текст: "идентификатор",        род: Род::Муж},

            // Ключевые слова
            ВидЛексемы::КлючПер             => Сущ{текст: "ключевое слово «пер»", род: Род::Сред},
            ВидЛексемы::КлючПро             => Сущ{текст: "ключевое слово «про»", род: Род::Сред},
            ВидЛексемы::КлючНч              => Сущ{текст: "ключевое слово «нч»",  род: Род::Сред},
            ВидЛексемы::КлючКц              => Сущ{текст: "ключевое слово «кц»",  род: Род::Сред},

            // Знаки препинания
            ВидЛексемы::ОткрытаяСкобка      => Сущ{текст: "открытая скобка",      род: Род::Жен},
            ВидЛексемы::ЗакрытаяСкобка      => Сущ{текст: "закрытая скобка",      род: Род::Жен},
            ВидЛексемы::ТочкаЗапятая        => Сущ{текст: "точка с запятой",      род: Род::Жен},
            ВидЛексемы::Запятая             => Сущ{текст: "запятая",              род: Род::Жен},
            ВидЛексемы::Плюс                => Сущ{текст: "плюс",                 род: Род::Муж},
            ВидЛексемы::Присваивание        => Сущ{текст: "присваивание",         род: Род::Сред},

            ВидЛексемы::Число               => Сущ{текст: "число",                род: Род::Сред},
            ВидЛексемы::Строка              => Сущ{текст: "строка",               род: Род::Жен},
            ВидЛексемы::НезавершённаяСтрока => Сущ{текст: "незавершённая строка", род: Род::Жен},
            ВидЛексемы::Неизвестная         => Сущ{текст: "неизвестная лексема",  род: Род::Жен},
        }
    }
}

#[derive(Debug, Clone)]
pub struct Лексема {
    pub вид: ВидЛексемы,
    pub текст: String,
    pub лок: Лок,
}

pub struct Лексер<'a> {
    pub символы: &'a [char],
    pub путь_к_файлу: &'a str,
    pub позиция: usize,
    pub начало_строки: usize,
    pub строка: usize,
}

impl<'a> Лексер<'a> {
    pub fn новый(путь_к_файлу: &'a str, символы: &'a [char]) -> Лексер<'a> {
        Лексер {
            символы,
            путь_к_файлу,
            позиция: 0,
            начало_строки: 0,
            строка: 0,
        }
    }

    pub fn текущий_символ(&self) -> Option<&char> {
        self.символы.get(self.позиция)
    }

    pub fn имеет_приставку(&self, приставка: &[char]) -> bool {
        self.символы[self.позиция..].starts_with(приставка)
    }

    pub fn отрезать_символы(&mut self, mut количество: usize) {
        while количество > 0 && self.текущий_символ().is_some() {
            self.отрезать_символ();
            количество -= 1;
        }
    }

    pub fn отрезать_символ(&mut self) {
        if let Some(&символ) = self.текущий_символ() {
            self.позиция += 1;
            if символ == '\n' {
                self.начало_строки = self.позиция;
                self.строка += 1;
            }
        }
    }

    pub fn подбрить_пробелы(&mut self) {
        while self.текущий_символ().map(|сим| сим.is_whitespace()).unwrap_or(false) {
            self.отрезать_символ();
        }
    }

    fn следующая_строка(&mut self) {
        while let Some(x) = self.текущий_символ().cloned() {
            self.отрезать_символ();
            if x == '\n' {
                break;
            }
        }
    }

    fn следующая_лексема(&mut self) -> Лексема {
        'подбрить_пробелы_и_комментарии: loop {
            self.подбрить_пробелы();
            if self.имеет_приставку(&['/', '/']) {
                self.следующая_строка();
            } else {
                break 'подбрить_пробелы_и_комментарии;
            }
        }

        let лок = Лок {
            строка: self.строка + 1,
            столбец: self.позиция - self.начало_строки + 1,
            путь_к_файлу: self.путь_к_файлу.to_string(),
        };

        let сим = if let Some(сим) = self.текущий_символ().cloned() {
            сим
        } else {
            return Лексема {
                вид: ВидЛексемы::Конец,
                текст: String::new(),
                лок,
            };
        };

        if сим.is_alphabetic() {
            let начало = self.позиция;
            while self.символы.get(self.позиция).map(|сим| сим.is_alphanumeric()).unwrap_or(false) {
                self.отрезать_символ();
            }
            let текст = self.символы[начало..self.позиция].iter().collect();
            for &(ключ, вид) in КЛЮЧЕВЫЕ_СЛОВА.iter() {
                if ключ == текст {
                    return Лексема {вид, текст, лок}
                }
            }
            return Лексема {
                вид: ВидЛексемы::Идент,
                текст,
                лок,
            }
        }

        if сим.is_numeric() {
            let начало = self.позиция;
            while self.символы.get(self.позиция).map(|сим| сим.is_numeric()).unwrap_or(false) {
                self.отрезать_символ();
            }
            let текст = self.символы[начало..self.позиция].iter().collect();
            return Лексема {
                вид: ВидЛексемы::Число,
                текст,
                лок,
            }
        }

        if сим == '"' || сим == '«' {
            self.отрезать_символ();
            let начало = self.позиция;
            while self.текущий_символ().map(|&сим| сим != '"' && сим != '»').unwrap_or(false) {
                self.отрезать_символ();
            }
            let текст = (&self.символы[начало..self.позиция]).iter().collect();
            match self.текущий_символ() {
                Some('"') | Some('»') => {
                    self.отрезать_символ();
                    return Лексема {
                        вид: ВидЛексемы::Строка,
                        текст,
                        лок,
                    };
                }
                Some(_) => unreachable!(),
                None => return Лексема {
                    вид: ВидЛексемы::НезавершённаяСтрока,
                    текст,
                    лок,
                }
            }
        }

        for &(приставка, вид) in ПРИСТАВКИ_ПРЕПИНАНИЙ.iter() {
            if self.имеет_приставку(приставка) {
                self.отрезать_символы(приставка.len());
                let текст = приставка.iter().collect();
                return Лексема {вид, текст, лок}
            }
        }

        self.отрезать_символ();
        Лексема {
            вид: ВидЛексемы::Неизвестная,
            текст: сим.to_string(),
            лок,
        }
    }

    pub fn ожидать_виды(&mut self, ожидаемые_виды: &[ВидЛексемы]) -> Option<Лексема> {
        assert!(ожидаемые_виды.len() > 0);

        let лексема = self.следующая_лексема();
        for ожидаемый_вид in ожидаемые_виды {
            if лексема.вид == *ожидаемый_вид {
                return Some(лексема)
            }
        }

        if ожидаемые_виды.len() == 1 {
            let ожидаемый_вид = ожидаемые_виды[0];
            диагностика!(&лексема.лок, "ОШИБКА",
                         "{ожидался} {ожидаемый_вид}, но {повстречался} {действительный_вид}",
                         ожидался           = ГЛАГОЛ_ОЖИДАЛСЯ.отобразить(&ожидаемый_вид.сущ().род),
                         ожидаемый_вид      = ожидаемый_вид.сущ().текст,
                         повстречался       = ГЛАГОЛ_ПОВСТРЕЧАЛСЯ.отобразить(&лексема.вид.сущ().род),
                         действительный_вид = лексема.вид.сущ().текст);
        } else {
            let mut список_видов = String::new();
            for (порядок, ожидаемый_вид) in ожидаемые_виды.iter().enumerate() {
                let ожидаемый_вид = ожидаемый_вид.сущ().текст;
                if порядок == 0 {
                    write!(&mut список_видов, "{ожидаемый_вид}").unwrap();
                } else {
                    write!(&mut список_видов, ", либо {ожидаемый_вид}").unwrap();
                }
            }
            диагностика!(&лексема.лок, "ОШИБКА",
                         "ожидались {список_видов}, но {повстречался} {действительный_вид}",
                         повстречался       = ГЛАГОЛ_ПОВСТРЕЧАЛСЯ.отобразить(&лексема.вид.сущ().род),
                         действительный_вид = лексема.вид.сущ().текст);
        }

        None
    }
}

impl<'a> Iterator for Лексер<'a> {
    type Item = Лексема;
    fn next(&mut self) -> Option<Self::Item> {
        let лексема = self.следующая_лексема();
        if лексема.вид != ВидЛексемы::Конец {
            Some(лексема)
        } else {
            None
        }
    }
}
