#[derive(Debug, Clone)]
pub struct Лок {
    pub путь_к_файлу: String,
    pub строка: usize,
    pub столбец: usize,
}

macro_rules! здесь {
    () => {
        ::диагностика::Лок {
            путь_к_файлу: file!().to_string(),
            строка: line!() as usize,
            столбец: column!() as usize,
        }
    }
}

macro_rules! диагностика {
    ($лок:expr, $уровень:literal, $($аргы:tt)*) => {
        let ::диагностика::Лок{путь_к_файлу, строка, столбец} = $лок;
        let уровень = $уровень;
        eprint!("{путь_к_файлу}:{строка}:{столбец}: {уровень}: ", );
        eprintln!($($аргы)*);
    };
}

macro_rules! сделать {
    ($лок:expr, $($аргы:tt)*) => {
        диагностика!($лок, "СДЕЛАТЬ", $($аргы)*);
        диагностика!(&здесь!(), "СДЕЛАТЬ", "реализация находится здесь");
    };
}

pub enum Род {
    Муж,
    Жен,
    Сред,
}

/// Существительное.
pub struct Сущ {
    pub род: Род,
    pub текст: &'static str,
}

/// Глагол в прошедшем времени.
///
/// Глаголы в прошелшем времени имеют разные окончания в зависимости
/// от рода существительного, к которому они пренадлежат. Данный тип
/// был создать чтобы учесть данную особенность.
pub struct ПрошлыйГлагол {
    pub муж: &'static str,
    pub жен: &'static str,
    pub сред: &'static str,
}

impl ПрошлыйГлагол {
    pub fn отобразить(&self, род: &Род) -> &str {
        match род {
            Род::Муж => self.муж,
            Род::Жен => self.жен,
            Род::Сред => self.сред,
        }
    }
}

// СДЕЛАТЬ: Рассмотреть вариант использования стеммеров для генерации глаголов в прошедшем времени.
// Можно взять стеммер из Snowball.

pub const ГЛАГОЛ_ОЖИДАЛСЯ: ПрошлыйГлагол = ПрошлыйГлагол {
    муж: "ожидался",
    жен: "ожидалась",
    сред: "ожидалось",
};

pub const ГЛАГОЛ_ПОВСТРЕЧАЛСЯ: ПрошлыйГлагол = ПрошлыйГлагол {
    муж: "повстречался",
    жен: "повстречалася",
    сред: "повстречалось",
};

pub const _ГЛАГОЛ_НАЙДЕН: ПрошлыйГлагол = ПрошлыйГлагол {
    муж: "найден",
    жен: "найдена",
    сред: "найдено",
};
