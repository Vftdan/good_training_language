use std::num::{IntErrorKind};
use std::collections::HashMap;
use лексика::*;

#[derive(Debug)]
pub enum Тип {
    Цел
}

impl Тип {
    fn разобрать(лекс: &mut Лексер) -> Option<Тип> {
        let имя_типа = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        match имя_типа.текст.as_str() {
            "цел" => Some(Тип::Цел),
            _ => {
                диагностика!(&имя_типа.лок, "ОШИБКА",
                             "неизвестный тип «{имя_типа}»",
                             имя_типа = &имя_типа.текст);
                None
            }
        }
    }
}

pub struct Переменная {
    pub имя: Лексема,
    pub тип: Тип,
}

impl Переменная {
    fn разобрать(лекс: &mut Лексер) -> Option<Переменная> {
        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        let тип = Тип::разобрать(лекс)?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
        Some(Переменная{имя, тип})
    }
}

#[derive(Debug)]
pub enum ВидБинопа {
    Мн
}

#[derive(Debug)]
pub enum Выражение {
    Число(usize),
    Строка(Лексема),
    Идент(Лексема),
    Биноп {
        вид: ВидБинопа,
        левое: Box<Выражение>,
        правое: Box<Выражение>,
    }
}

impl Выражение {
    fn разобрать_первичное(лекс: &mut Лексер) -> Option<Выражение> {
        let лексема = лекс.вытащить_лексему_вида(&[
            ВидЛексемы::Число,
            ВидЛексемы::Идент,
            ВидЛексемы::Строка
        ])?;
        match лексема.вид {
            ВидЛексемы::Число => {
                match лексема.текст.parse() {
                    Ok(число) => Some(Выражение::Число(число)),
                    Err(ошибка) => match ошибка.kind() {
                        IntErrorKind::PosOverflow => {
                            диагностика!(&лексема.лок, "ОШИБКА", "Число слишком большое");
                            None
                        }
                        IntErrorKind::Empty => unreachable!(),
                        IntErrorKind::InvalidDigit => unreachable!(),
                        IntErrorKind::NegOverflow => unreachable!(),
                        IntErrorKind::Zero => unreachable!(),
                        _ => {
                            диагностика!(&лексема.лок, "ОШИБКА", "Число некорректно");
                            None
                        }
                    }
                }
            }
            ВидЛексемы::Идент => Some(Выражение::Идент(лексема)),
            ВидЛексемы::Строка => Some(Выражение::Строка(лексема)),
            _ => unreachable!(),
        }
    }

    fn разобрать_биноп(лекс: &mut Лексер) -> Option<Выражение> {
        let левое = Выражение::разобрать_первичное(лекс)?;
        if let Some(ВидЛексемы::КлючМн) = лекс.подсмотреть_лексему().map(|лексема| лексема.вид) {
            let _ = лекс.вытащить_лексему();
            let правое = Выражение::разобрать_биноп(лекс)?;
            Some(Выражение::Биноп {
                вид: ВидБинопа::Мн,
                левое: Box::new(левое),
                правое: Box::new(правое),
            })
        } else {
            Some(левое)
        }
    }

    fn разобрать(лекс: &mut Лексер) -> Option<Выражение> {
        Выражение::разобрать_биноп(лекс)
    }
}

#[derive(Debug)]
pub enum Утверждение {
    Присваивание{имя: Лексема, значение: Выражение},
    Вызов{имя: Лексема, аргументы: Vec<Выражение>},
    Пока{условие: Выражение, тело: Vec<Утверждение>},
}

#[derive(Debug)]
pub struct Процедура {
    pub имя: Лексема,
    pub тело: Vec<Утверждение>
}

fn разобрать_блок_кода(лекс: &mut Лексер) -> Option<Vec<Утверждение>> {
    let mut блок = Vec::new();
    let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::КлючНч])?;
    loop {
        let лексема = лекс.вытащить_лексему_вида(&[
            ВидЛексемы::Идент,
            ВидЛексемы::КлючПока,
            ВидЛексемы::КлючКц,
        ])?;
        match лексема.вид {
            ВидЛексемы::Идент => {
                let имя = лексема;
                let лексема = лекс.вытащить_лексему_вида(&[
                    ВидЛексемы::Присваивание,
                    ВидЛексемы::ОткрытаяСкобка
                ])?;
                match лексема.вид {
                    ВидЛексемы::Присваивание => {
                        let значение = Выражение::разобрать(лекс)?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                        блок.push(Утверждение::Присваивание {
                            имя,
                            значение
                        });
                    }
                    ВидЛексемы::ОткрытаяСкобка => {
                        let аргумент = Выражение::разобрать(лекс)?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ЗакрытаяСкобка])?;
                        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
                        блок.push(Утверждение::Вызов {
                            имя,
                            аргументы: vec![аргумент],
                        });
                    }
                    _ => unreachable!()
                }
            }
            ВидЛексемы::КлючПока => {
                let условие = Выражение::разобрать(лекс)?;
                let тело = разобрать_блок_кода(лекс)?;
                блок.push(Утверждение::Пока{условие, тело});
            }
            ВидЛексемы::КлючКц => break,
            _ => unreachable!(),
        }
    }
    Some(блок)
}

impl Процедура {
    fn разобрать(лекс: &mut Лексер) -> Option<Процедура> {
        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ОткрытаяСкобка])?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ЗакрытаяСкобка])?;
        let тело = разобрать_блок_кода(лекс)?;
        Some(Процедура{имя, тело})
    }
}

pub struct Константа {
    имя: Лексема,
    _значение: Выражение,
}

impl Константа {
    fn разобрать(лекс: &mut Лексер) -> Option<Константа> {
        let имя = лекс.вытащить_лексему_вида(&[ВидЛексемы::Идент])?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::Равно])?;
        let _значение = Выражение::разобрать(лекс)?;
        let _ = лекс.вытащить_лексему_вида(&[ВидЛексемы::ТочкаЗапятая])?;
        Some(Константа{имя, _значение})
    }
}

#[derive(Default)]
pub struct Модуль {
    pub переменные: HashMap<String, Переменная>,
    pub процедуры: HashMap<String, Процедура>,
    pub константы: HashMap<String, Константа>,
}

impl Модуль {
    fn верифицировать_переопределение_имени(&self, имя: &Лексема) -> Option<()> {
        if let Some(существующая_переменная) = self.переменные.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует переменная с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return None
        }

        if let Some(существующая_процедура) = self.процедуры.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует процедура с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return None
        }

        if let Some(существующая_константа) = self.константы.get(&имя.текст) {
            диагностика!(&имя.лок, "ОШИБКА",
                         "уже существует константа с именем «{имя}»",
                         имя = имя.текст);
            диагностика!(&существующая_константа.имя.лок, "ИНФО",
                         "она определена здесь здесь. Выберите другое имя.");
            return None
        }

        Some(())
    }

    pub fn разобрать(лекс: &mut Лексер) -> Option<Модуль> {
        let mut модуль = Модуль::default();
        loop {
            let ключ = лекс.вытащить_лексему_вида(&[
                ВидЛексемы::КлючПер,
                ВидЛексемы::КлючПро,
                ВидЛексемы::КлючКонст,
                ВидЛексемы::Конец,
            ])?;
            // СДЕЛАТЬ: проверка на коллизии между переменными, процедурами, константами, тд.
            match ключ.вид {
                ВидЛексемы::КлючПер => {
                    let переменная = Переменная::разобрать(лекс)?;
                    модуль.верифицировать_переопределение_имени(&переменная.имя)?;
                    модуль.переменные.insert(переменная.имя.текст.clone(), переменная);
                }
                ВидЛексемы::КлючПро => {
                    let процедура = Процедура::разобрать(лекс)?;
                    модуль.верифицировать_переопределение_имени(&процедура.имя)?;
                    модуль.процедуры.insert(процедура.имя.текст.clone(), процедура);
                }
                ВидЛексемы::КлючКонст => {
                    let константа = Константа::разобрать(лекс)?;
                    модуль.верифицировать_переопределение_имени(&константа.имя)?;
                    модуль.константы.insert(константа.имя.текст.clone(), константа);
                }
                ВидЛексемы::Конец => return Some(модуль),
                _ => unreachable!(),
            }
        }
    }
}
