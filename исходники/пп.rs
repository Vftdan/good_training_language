/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use синтаксис::{Процедура, Модуль, Утверждение, Выражение, ВидБинопа, Тип};
use std::io;
use std::io::Write;

/// Инструкция промежуточного представления
#[derive(Debug)]
pub enum Инструкция {
    /// Протолкнуть целое значение на стек аргументов.
    ПротолкнутьЦелое(usize),
    /// Протолкнуть указатель на данные.
    ///
    /// Эта инстуркция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ПротолкнутьУказатель(usize),
    Записать64,
    ПечатьСтроки,
    ПечатьЦелого,
    ПечатьЛогического,
    Возврат
}

#[derive(Debug, Default)]
pub struct Программа {
    pub код: Vec<Инструкция>,
    pub данные: Vec<u8>,
    pub значения_констант: HashMap<String, usize>,
    pub точки_входа_процедур: HashMap<String, usize>,
    pub адреса_переменных: HashMap<String, usize>,
}

impl Программа {
    fn скомпилировать_выражение(&mut self, выражение: Выражение) -> Результат<Тип> {
        match выражение {
            Выражение::Число(число) => {
                self.код.push(Инструкция::ПротолкнутьЦелое(число));
                Ok(Тип::Цел)
            },
            Выражение::Строка(строка) => {
                let указатель = self.данные.len();
                let длинна = строка.текст.len();
                self.данные.extend(строка.текст.as_bytes());
                self.код.push(Инструкция::ПротолкнутьЦелое(длинна));
                self.код.push(Инструкция::ПротолкнутьУказатель(указатель));
                Ok(Тип::Строка)
            }
            Выражение::Идент(_) => todo!("СДЕЛАТЬ: Компиляция идентификаторов"),
            Выражение::Биноп {..} => todo!("СДЕЛАТЬ: Компиляция бинарных операция"),
        }
    }

    fn скомпилировать_утвержление(&mut self, утверждение: Утверждение) -> Результат<()> {
        match утверждение {
            Утверждение::Присваивание{имя, значение} => {
                if let Some(адрес) = self.адреса_переменных.get(имя.текст.as_str()) {
                    self.код.push(Инструкция::ПротолкнутьУказатель(*адрес));
                    let _тип = self.скомпилировать_выражение(значение)?;
                    self.код.push(Инструкция::Записать64);
                    Ok(())
                } else {
                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменных «{имя}»", имя = имя.текст);
                    return Err(())
                }
            },
            Утверждение::Вызов{имя, аргументы} => {
                match имя.текст.as_str() {
                    "печать" => {
                        for арг in аргументы {
                            let тип = self.скомпилировать_выражение(арг)?;
                            match тип {
                                Тип::Строка => self.код.push(Инструкция::ПечатьСтроки),
                                Тип::Цел => self.код.push(Инструкция::ПечатьЦелого),
                                Тип::Лог => self.код.push(Инструкция::ПечатьЛогического),
                            }
                        }
                        Ok(())
                    },
                    _ => {
                        диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                        return Err(())
                    }
                }
            }
            Утверждение::Пока{..} => {
                // СДЕЛАТЬ: Для начала, введи понятие Области вместо
                // Локации. Область, вместо одной строки и одной
                // колонки, определяет диапозон строк и колонок, таким
                // образом, определяя область в исходном коде заместа
                // одной точки, что очень удобно при диагностики
                // выражений, которые могут занимать значительную
                // часть места в файле.
                //
                // Формат диагностики, может быть такой:
                // «файл»:«нч-стр»..«кч-стр»:«нч-клн»..«кч-клн»: «сообщение-диагностики»
                //
                // Если, на пример, «нч-стр» == «кч-стр» и «нч-клн» == «кч-клн»,
                // то можно записать как старый формат
                //
                // «файл»:«стр»:«клн»: «сообщение-диагностики»
                //
                // Так же, не забудь обновить режим-хуя, чтобы он
                // поддерживал данный формат.
                todo!("СДЕЛАТЬ: компиляция цикла «пока»");
            }
        }
    }

    fn скомпилировать_процедуру(&mut self, процедура: Процедура) -> Результат<usize> {
        let точка_входа = self.код.len();
        for утверждение in процедура.тело {
            self.скомпилировать_утвержление(утверждение)?;
        }
        self.код.push(Инструкция::Возврат);
        Ok(точка_входа)
    }

    fn интерпретировать_выражение_константы(&mut self, выражение: Выражение) -> Результат<usize> {
        match выражение {
            Выражение::Число(число) => Ok(число),
            Выражение::Строка(строка) => {
                диагностика!(&строка.лок, "СДЕЛАТЬ", "Строковые константы пока не поддерживаются");
                Err(())
            }
            Выражение::Идент(имя) => {
                if let Some(значение) = self.значения_констант.get(имя.текст.as_str()) {
                    Ok(*значение)
                } else {
                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                    Err(())
                }
            }
            Выражение::Биноп{вид, ключ, левое, правое} => {
                let левое_значение = self.интерпретировать_выражение_константы(*левое)?;
                let правое_значение = self.интерпретировать_выражение_константы(*правое)?;
                match вид {
                    ВидБинопа::Меньше => {
                        диагностика!(&ключ.лок, "СДЕЛАТЬ", "Булевые константы пока не поддерживаются");
                        Err(())
                    },
                    ВидБинопа::Сложение => {
                        Ok(левое_значение + правое_значение)
                    }
                }
            }
        }
    }

    pub fn скомпилировать_модуль(&mut self, mut модуль: Модуль) -> Результат<()> {
        for (имя, константа) in модуль.константы.drain() {
            let значение = self.интерпретировать_выражение_константы(константа.выражение)?;
            if let Some(_) = self.значения_констант.insert(имя, значение) {
                unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
            }
        }
        for (имя, переменная) in модуль.переменные.drain() {
            let адрес = self.данные.len();
            let новый_размер = self.данные.len() + переменная.тип.размер();
            self.данные.resize(новый_размер, 0u8);
            if let Some(_) = self.адреса_переменных.insert(имя, адрес) {
                unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
            }
        }
        for (имя, процедура) in модуль.процедуры.drain() {
            let точка_входа = self.скомпилировать_процедуру(процедура)?;
            if let Some(_) = self.точки_входа_процедур.insert(имя, точка_входа) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }
        }
        Ok(())
    }

    pub fn интерпретировать(&self, процедура_точки_входа: &str) -> Результат<()> {
        let mut индекс_инструкции = match self.точки_входа_процедур.get(процедура_точки_входа) {
            Some(точка_входа) => *точка_входа,
            None => {
                eprintln!("ОШИБКА: процедура точка входа «{процедура_точки_входа}» не найдена! Пожалуйста определите её!");
                return Err(());
            }
        };

        let mut стек: Vec<usize> = Vec::new();

        loop {
            let инструкция = match self.код.get(индекс_инструкции) {
                Some(инструкция) => инструкция,
                None => {
                    eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный индекс инструкции {индекс_инструкции}");
                    return Err(());
                }
            };

            match инструкция {
                Инструкция::ПротолкнутьЦелое(значение) => {
                    стек.push(*значение);
                    индекс_инструкции += 1;
                }
                Инструкция::ПротолкнутьУказатель(указатель) => {
                    // ЗАМЕЧАНИЕ: Т.к. во время интерпретации, адреса
                    // данных начинаются с нуля, реализация
                    // ПротолкнутьУказатель ни чем не отличается от
                    // ПротолкнутьЦелое.
                    стек.push(*указатель);
                    индекс_инструкции += 1;
                }
                Инструкция::Записать64 => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции Записать64");
                }
                Инструкция::ПечатьСтроки => {
                    if стек.len() < 2 {
                        eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: недостаточно аргументов для инструкции печати строки");
                        return Err(())
                    }

                    let указатель = стек.pop().unwrap();
                    let длинна = стек.pop().unwrap();

                    if let Some(строка) = self.данные.get(указатель..указатель + длинна) {
                        let _ = io::stdout().write(строка);
                    } else {
                        eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный адрес ({указатель}) и длинна строки ({длинна})");
                        return Err(())
                    }

                    индекс_инструкции += 1;
                }
                Инструкция::ПечатьЦелого => todo!("СДЕЛАТЬ: Интерпретация инструкции ПечатьЦелого"),
                Инструкция::ПечатьЛогического => todo!("СДЕЛАТЬ: Интерпретация инструкции ПечатьЛогического"),
                Инструкция::Возврат => break,
            }
        }
        Ok(())
    }
}
