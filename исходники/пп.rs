/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use синтаксис::*;
use std::io;
use std::io::Write;

/// Инструкция промежуточного представления
#[derive(Debug)]
pub enum Инструкция {
    Ноп,
    /// Протолкнуть целое значение на стек аргументов.
    ПротолкнутьЦелое(usize),
    /// Протолкнуть указатель на данные.
    ///
    /// Эта инстуркция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ПротолкнутьУказатель(usize),
    Записать64,
    Прочитать64,
    ЦелСложение,
    ЦелМеньше,
    ЛогОтрицание,
    ПечатьСтроки,
    ПечатьЦелого,
    ПечатьЛогического,
    Возврат,
    Прыжок(usize),
    УсловныйПрыжок(usize),
}

#[derive(Clone)]
pub struct СкомпПеременная {
    синтаксис: Переменная,
    адрес: usize,
}

#[derive(Default)]
pub struct Программа {
    pub код: Vec<Инструкция>,
    pub данные: Vec<u8>,
    pub значения_констант: HashMap<String, usize>,
    pub точки_входа_процедур: HashMap<String, usize>,
    pub скомпилированные_переменные: HashMap<String, СкомпПеременная>,
}

impl Программа {
    fn скомпилировать_выражение(&mut self, выражение: &Выражение) -> Результат<Тип> {
        match выражение {
            Выражение::Число(_, число) => {
                self.код.push(Инструкция::ПротолкнутьЦелое(*число));
                Ok(Тип::Цел)
            },
            Выражение::Строка(строка) => {
                let указатель = self.данные.len();
                let длинна = строка.текст.len();
                self.данные.extend(строка.текст.as_bytes());
                self.код.push(Инструкция::ПротолкнутьЦелое(длинна));
                self.код.push(Инструкция::ПротолкнутьУказатель(указатель));
                Ok(Тип::Строка)
            }
            Выражение::Идент(лексема) => {
                if let Some(значение) = self.значения_констант.get(&лексема.текст) {
                    self.код.push(Инструкция::ПротолкнутьЦелое(*значение));
                    return Ok(Тип::Цел);
                }
                if let Some(переменная) = self.скомпилированные_переменные.get(&лексема.текст) {
                    self.код.push(Инструкция::ПротолкнутьУказатель(переменная.адрес));
                    match переменная.синтаксис.тип {
                        Тип::Цел => {
                            self.код.push(Инструкция::Прочитать64);
                            return Ok(Тип::Цел);
                        }
                        Тип::Лог => {
                            сделать!(&лексема.лок, "чтение логических переменных");
                            return Err(())
                        }
                        Тип::Строка => {
                            сделать!(&лексема.лок, "чтение строковых переменных");
                            return Err(())
                        }
                    }
                }
                диагностика!(&лексема.лок, "ОШИБКА",
                             "не существует ни констант, ни переменных с имением «{имя}»",
                             имя = &лексема.текст);
                Err(())
            }
            Выражение::Биноп {ключ: _, вид, левое, правое} => {
                let левый_тип = self.скомпилировать_выражение(&левое)?;
                let правый_тип = self.скомпилировать_выражение(&правое)?;
                match вид {
                    ВидБинопа::Меньше => {
                        проверить_типы(левое.лок(), &Тип::Цел, &левый_тип)?;
                        проверить_типы(правое.лок(), &Тип::Цел, &правый_тип)?;
                        self.код.push(Инструкция::ЦелМеньше);
                        Ok(Тип::Лог)
                    }
                    ВидБинопа::Сложение => {
                        проверить_типы(левое.лок(), &Тип::Цел, &левый_тип)?;
                        проверить_типы(правое.лок(), &Тип::Цел, &правый_тип)?;
                        self.код.push(Инструкция::ЦелСложение);
                        Ok(Тип::Цел)
                    }
                }
            }
        }
    }

    fn скомпилировать_утвержление(&mut self, утверждение: &Утверждение) -> Результат<()> {
        match утверждение {
            Утверждение::Присваивание{имя, значение, ..} => {
                // ЗАМЕЧАНИЕ: Причина по которой мы клонируем (cloned)
                // скомпилированную переменную заключается в том, что
                // последующие вызовы «self.скомпилировать_выражение()»
                // потенциально могут модифицировать хeш-таблицу
                // «self.скомпилированные_переменные» тем самым
                // инвалидируя указатель на «переменная». Поэтому мы
                // храним её компию на стеке.
                if let Some(переменная) = self.скомпилированные_переменные.get(имя.текст.as_str()).cloned() {
                    self.код.push(Инструкция::ПротолкнутьУказатель(переменная.адрес));
                    let тип = self.скомпилировать_выражение(&значение)?;
                    проверить_типы(&значение.лок(), &переменная.синтаксис.тип, &тип)?;
                    self.код.push(Инструкция::Записать64);
                    Ok(())
                } else {
                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестная переменная «{имя}»", имя = имя.текст);
                    return Err(())
                }
            },
            Утверждение::Вызов{имя, аргументы} => {
                match имя.текст.as_str() {
                    "печать" => {
                        for арг in аргументы {
                            let тип = self.скомпилировать_выражение(&арг)?;
                            match тип {
                                Тип::Строка => self.код.push(Инструкция::ПечатьСтроки),
                                Тип::Цел => self.код.push(Инструкция::ПечатьЦелого),
                                Тип::Лог => self.код.push(Инструкция::ПечатьЛогического),
                            }
                        }
                        Ok(())
                    },
                    _ => {
                        диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                        return Err(())
                    }
                }
            }
            Утверждение::Пока{ключ: _, условие, тело} => {
                let точка_условия = self.код.len();
                let тип = self.скомпилировать_выражение(&условие)?;
                проверить_типы(&условие.лок(), &Тип::Лог, &тип)?;
                self.код.push(Инструкция::ЛогОтрицание);
                let точка_условного_прыжка = self.код.len();
                self.код.push(Инструкция::Ноп);
                for утверждение in тело.iter() {
                    self.скомпилировать_утвержление(утверждение)?;
                }
                self.код.push(Инструкция::Прыжок(точка_условия));
                let точка_выхода = self.код.len();
                self.код[точка_условного_прыжка] = Инструкция::УсловныйПрыжок(точка_выхода);
                Ok(())
            }
        }
    }

    fn скомпилировать_процедуру(&mut self, процедура: Процедура) -> Результат<usize> {
        let точка_входа = self.код.len();
        for утверждение in процедура.тело {
            self.скомпилировать_утвержление(&утверждение)?;
        }
        self.код.push(Инструкция::Возврат);
        Ok(точка_входа)
    }

    fn интерпретировать_выражение_константы(&mut self, выражение: Выражение) -> Результат<usize> {
        match выражение {
            Выражение::Число(_, число) => Ok(число),
            Выражение::Строка(строка) => {
                сделать!(&строка.лок, "строковые константы");
                Err(())
            }
            Выражение::Идент(имя) => {
                if let Some(значение) = self.значения_констант.get(имя.текст.as_str()) {
                    Ok(*значение)
                } else {
                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                    Err(())
                }
            }
            Выражение::Биноп{ключ, вид, левое, правое, ..} => {
                let левое_значение = self.интерпретировать_выражение_константы(*левое)?;
                let правое_значение = self.интерпретировать_выражение_константы(*правое)?;
                match вид {
                    ВидБинопа::Меньше => {
                        сделать!(&ключ.лок, "булевые константы");
                        Err(())
                    },
                    ВидБинопа::Сложение => {
                        Ok(левое_значение + правое_значение)
                    }
                }
            }
        }
    }

    pub fn скомпилировать_модуль(&mut self, mut модуль: Модуль) -> Результат<()> {
        for (имя, константа) in модуль.константы.drain() {
            let значение = self.интерпретировать_выражение_константы(константа.выражение)?;
            if let Some(_) = self.значения_констант.insert(имя, значение) {
                unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
            }
        }
        for (имя, переменная) in модуль.переменные.drain() {
            let адрес = self.данные.len();
            let новый_размер = self.данные.len() + переменная.тип.размер();
            self.данные.resize(новый_размер, 0u8);
            if let Some(_) = self.скомпилированные_переменные.insert(имя, СкомпПеременная {адрес, синтаксис: переменная}) {
                unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
            }
        }
        for (имя, процедура) in модуль.процедуры.drain() {
            let точка_входа = self.скомпилировать_процедуру(процедура)?;
            if let Some(_) = self.точки_входа_процедур.insert(имя, точка_входа) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }
        }
        Ok(())
    }

    pub fn интерпретировать(&self, процедура_точки_входа: &str) -> Результат<()> {
        let mut индекс_инструкции = match self.точки_входа_процедур.get(процедура_точки_входа) {
            Some(точка_входа) => *точка_входа,
            None => {
                eprintln!("ОШИБКА: процедура точка входа «{процедура_точки_входа}» не найдена! Пожалуйста определите её!");
                return Err(());
            }
        };

        let mut стек: Vec<usize> = Vec::new();

        loop {
            let инструкция = match self.код.get(индекс_инструкции) {
                Some(инструкция) => инструкция,
                None => {
                    eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный индекс инструкции {индекс_инструкции}");
                    return Err(());
                }
            };

            match инструкция {
                Инструкция::Ноп => {
                    индекс_инструкции += 1;
                }
                Инструкция::ПротолкнутьЦелое(значение) => {
                    стек.push(*значение);
                    индекс_инструкции += 1;
                }
                Инструкция::ПротолкнутьУказатель(указатель) => {
                    // ЗАМЕЧАНИЕ: Т.к. во время интерпретации, адреса
                    // данных начинаются с нуля, реализация
                    // ПротолкнутьУказатель ни чем не отличается от
                    // ПротолкнутьЦелое.
                    стек.push(*указатель);
                    индекс_инструкции += 1;
                }
                Инструкция::Записать64 => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции Записать64");
                }
                Инструкция::Прочитать64 => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции Прочитать64");
                }
                Инструкция::ЦелМеньше => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции ЦелМеньше");
                }
                Инструкция::ЦелСложение => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции ЦелСложение");
                }
                Инструкция::ЛогОтрицание => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции ЛогОтрицание");
                }
                Инструкция::Прыжок(_) => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции Прыжок");
                }
                Инструкция::УсловныйПрыжок(_) => {
                    todo!("СДЕЛАТЬ: интерпретация инструкции УсловныйПрыжок");
                }
                Инструкция::ПечатьСтроки => {
                    if стек.len() < 2 {
                        eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: недостаточно аргументов для инструкции печати строки");
                        return Err(())
                    }

                    let указатель = стек.pop().unwrap();
                    let длинна = стек.pop().unwrap();

                    if let Some(строка) = self.данные.get(указатель..указатель + длинна) {
                        let _ = io::stdout().write(строка);
                    } else {
                        eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный адрес ({указатель}) и длинна строки ({длинна})");
                        return Err(())
                    }

                    индекс_инструкции += 1;
                }
                Инструкция::ПечатьЦелого => todo!("СДЕЛАТЬ: Интерпретация инструкции ПечатьЦелого"),
                Инструкция::ПечатьЛогического => todo!("СДЕЛАТЬ: Интерпретация инструкции ПечатьЛогического"),
                Инструкция::Возврат => break,
            }
        }
        Ok(())
    }
}
