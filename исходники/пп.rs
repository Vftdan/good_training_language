/// Промежуточное Представление

use super::Результат;
use std::collections::HashMap;
use синтаксис::{Процедура, Модуль, Утверждение, Выражение, ВидБинопа};
use std::io;
use std::io::Write;

/// Инструкция промежуточного представления
#[derive(Debug)]
pub enum Инструкция {
    /// Протолкнуть целое значение на стек аргументов.
    ПротолкнутьЦелое(usize),
    /// Протолкнуть указатель на данные.
    ///
    /// Эта инстуркция нужна потому, что мы не знаем во время
    /// компиляции где начинаются данные. Мы это только знаем во время
    /// интерпретации, либо генерации машинного кода.
    ПротолкнутьУказатель(usize),
    ПечатьСтроки,
    Возврат
}

#[derive(Debug, Default)]
pub struct Программа {
    pub код: Vec<Инструкция>,
    pub данные: Vec<u8>,
    pub значения_констант: HashMap<String, usize>,
    pub точки_входа_процедур: HashMap<String, usize>,
    pub адреса_переменных: HashMap<String, usize>,
}

impl Программа {
    fn скомпилировать_утвержление(&mut self, утверждение: &Утверждение) -> Результат<()> {
        match утверждение {
            Утверждение::Присваивание{..} => todo!("СДЕЛАТЬ: компиляция присваивания"),
            Утверждение::Вызов{имя, аргументы} => {
                match имя.текст.as_str() {
                    "печать" => {
                        for арг in аргументы {
                            match арг {
                                Выражение::Строка(строка) => {
                                    let указатель = self.данные.len();
                                    let длинна = строка.текст.len();
                                    self.данные.extend(строка.текст.as_bytes());
                                    self.код.push(Инструкция::ПротолкнутьЦелое(длинна));
                                    self.код.push(Инструкция::ПротолкнутьУказатель(указатель));
                                    self.код.push(Инструкция::ПечатьСтроки);
                                }
                                Выражение::Число(_) => todo!("СДЕЛАТЬ: печать чисел"),
                                Выражение::Идент(_) => todo!("СДЕЛАТЬ: печать значений идентификаторов"),
                                // СДЕЛАТЬ: Вообще, выражения при печати нужно сначала вычислить.
                                // А как только они вычисленны, распределять по их типу данных.
                                Выражение::Биноп{..} => todo!("СДЕЛАТЬ: печать бинопов"),
                            }
                        }
                        Ok(())
                    },
                    _ => {
                        диагностика!(&имя.лок, "ОШИБКА", "Неизвестная процедура «{имя}»", имя = имя.текст);
                        return Err(())
                    }
                }
            }
            Утверждение::Пока{..} => {
                todo!("СДЕЛАТЬ: компиляция цикла «пока»");
            }
        }
    }

    fn скомпилировать_процедуру(&mut self, процедура: &Процедура) -> Результат<usize> {
        let точка_входа = self.код.len();
        for утверждение in &процедура.тело {
            self.скомпилировать_утвержление(&утверждение)?;
        }
        self.код.push(Инструкция::Возврат);
        Ok(точка_входа)
    }

    fn интерпретировать_выражение_константы(&mut self, выражение: &Выражение) -> Результат<usize> {
        match выражение {
            Выражение::Число(число) => Ok(*число),
            Выражение::Строка(строка) => {
                диагностика!(&строка.лок, "СДЕЛАТЬ", "Строковые константы пока не поддерживаются");
                Err(())
            }
            Выражение::Идент(имя) => {
                if let Some(значение) = self.значения_констант.get(имя.текст.as_str()) {
                    Ok(*значение)
                } else {
                    диагностика!(&имя.лок, "ОШИБКА", "Неизвестная константа «{имя}»", имя = имя.текст);
                    Err(())
                }
            }
            Выражение::Биноп{вид, ключ, левое, правое} => {
                let левое_значение = self.интерпретировать_выражение_константы(левое)?;
                let правое_значение = self.интерпретировать_выражение_константы(правое)?;
                match вид {
                    ВидБинопа::Меньше => {
                        диагностика!(&ключ.лок, "СДЕЛАТЬ", "Булевые константы пока не поддерживаются");
                        Err(())
                    },
                    ВидБинопа::Сложение => {
                        Ok(левое_значение + правое_значение)
                    }
                }
            }
        }
    }

    pub fn скомпилировать_модуль(&mut self, модуль: &Модуль) -> Результат<()> {
        // СДЕЛАТЬ: использовать HashMap::drain() для итерации по
        // таблицам процедур, переменных и тд. Это может потребовать
        // передавать «модуль» с перемещение вместо по-ссылке.
        for (имя, константа) in &модуль.константы {
            let значение = self.интерпретировать_выражение_константы(&константа.выражение)?;
            if let Some(_) = self.значения_констант.insert(имя.clone(), значение) {
                unreachable!("Проверка переопределения констант должна происходить на этапе разбора")
            }
        }
        for (имя, переменная) in &модуль.переменные {
            let адрес = self.данные.len();
            let новый_размер = self.данные.len() + переменная.тип.размер();
            self.данные.resize(новый_размер, 0u8);
            if let Some(_) = self.адреса_переменных.insert(имя.clone(), адрес) {
                unreachable!("Проверка переопределения переменных должна происходить на этапе разбора")
            }
        }
        for (имя, процедура) in &модуль.процедуры {
            let точка_входа = self.скомпилировать_процедуру(&процедура)?;
            if let Some(_) = self.точки_входа_процедур.insert(имя.clone(), точка_входа) {
                unreachable!("Проверка переопределения процедур должна происходить на этапе разбора")
            }
        }
        Ok(())
    }

    pub fn интерпретировать(&self, процедура_точки_входа: &str) -> Результат<()> {
        let mut индекс_инструкции = match self.точки_входа_процедур.get(процедура_точки_входа) {
            Some(точка_входа) => *точка_входа,
            None => {
                eprintln!("ОШИБКА: процедура точка входа «{процедура_точки_входа}» не найдена! Пожалуйста определите её!");
                return Err(());
            }
        };

        let mut стек: Vec<usize> = Vec::new();

        loop {
            let инструкция = match self.код.get(индекс_инструкции) {
                Some(инструкция) => инструкция,
                None => {
                    eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный индекс инструкции {индекс_инструкции}");
                    return Err(());
                }
            };

            match инструкция {
                Инструкция::ПротолкнутьЦелое(значение) => {
                    стек.push(*значение);
                    индекс_инструкции += 1;
                }
                Инструкция::ПротолкнутьУказатель(указатель) => {
                    // ЗАМЕЧАНИЕ: Т.к. во время интерпретации, адреса
                    // данных начинаются с нуля, реализация
                    // ПротолкнутьУказатель ни чем не отличается от
                    // ПротолкнутьЦелое.
                    стек.push(*указатель);
                    индекс_инструкции += 1;
                }
                Инструкция::ПечатьСтроки => {
                    if стек.len() < 2 {
                        eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: недостаточно аргументов для инструкции печати строки");
                        return Err(())
                    }

                    let указатель = стек.pop().unwrap();
                    let длинна = стек.pop().unwrap();

                    if let Some(строка) = self.данные.get(указатель..указатель + длинна) {
                        let _ = io::stdout().write(строка);
                    } else {
                        eprintln!("ОШИБКА ВРЕМЕНИ ИСПОЛНЕНИЯ: некорректный адрес ({указатель}) и длинна строки ({длинна})");
                        return Err(())
                    }

                    индекс_инструкции += 1;
                },
                Инструкция::Возврат => break,
            }
        }
        Ok(())
    }
}
