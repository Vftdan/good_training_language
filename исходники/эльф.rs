use super::Результат;
use std::fs;
use std::path::Path;
use std::io::Write;
use пп::{Инструкция, Программа};

pub fn сгенерировать(путь_к_файлу: &Path, программа: &Программа) -> Результат<()> {
    let размер_заголовков: u64 = 64 + 56;
    let точка_входа: u64 = 0x400000;
    let начало_данных = точка_входа + размер_заголовков;
    let mut код = vec![];

    код.extend(&программа.данные);

    for инструкция in &программа.код {
        match инструкция {
            Инструкция::Ноп => {}
            // «Короткое» проталкивание (i8) "\x6A\x7F"
            // «Длинное» проталкивание (i32) "\x68\x00\x00\x00\x00"
            Инструкция::ПротолкнутьЦелое(значение) => {
                assert!(*значение <= i32::MAX as usize);
                код.push(0x68);
                код.extend((*значение as i32).to_le_bytes());
                // СДЕЛАТЬ: реализовать поддержу «коротких» проталкиваний для целых чисел.
            }
            Инструкция::ПротолкнутьУказатель(указатель) => {
                let значение = указатель + начало_данных as usize;
                assert!(значение <= i32::MAX as usize);
                код.push(0x68);
                код.extend((значение as i32).to_le_bytes());
            },
            Инструкция::Записать64 => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции Записать64");
            }
            Инструкция::Прочитать64 => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции Прочитать64");
            }
            Инструкция::ЦелМеньше => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции ЦелМеньше");
            }
            Инструкция::ЦелСложение => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции ЦелСложение");
            }
            Инструкция::ЛогОтрицание => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции ЛогОтрицание");
            }
            Инструкция::Прыжок(_) => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции Прыжок");
            }
            Инструкция::УсловныйПрыжок(_) => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции УсловныйПрыжок");
            }
            Инструкция::ПечатьСтроки => {
                // SYS_write
                код.extend([0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00]); // mov rax, 1
                код.extend([0x48, 0xC7, 0xC7, 0x01, 0x00, 0x00, 0x00]); // mov rdi, 1
                код.extend([0x5e]); // pop rsi
                код.extend([0x5A]); // pop rdx
                код.extend([0x0F, 0x05]); // syscall
            },
            Инструкция::ПечатьЦелого => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции ПечатьЦелого");
            },
            Инструкция::ПечатьЛогического => {
                todo!("СДЕЛАТЬ: генерация машинного кода для инструкции ПечатьЛогического");
            },
            Инструкция::Возврат => {
                // SYS_exit
                код.extend([0x48, 0xC7, 0xC0, 0x3C, 0x00, 0x00, 0x00]); // mov rax, 60
                код.extend([0x48, 0xC7, 0xC7, 0x00, 0x00, 0x00, 0x00]); // mov rdi, 0
                код.extend([0x0F, 0x05]); // syscall
            }
        }
    }

    let mut байты: Vec<u8> = Vec::new();
    байты.extend([0x7f, 0x45, 0x4c, 0x46,
                  0x02, 0x01, 0x01, 0x00,
                  0x00, 0x00, 0x00, 0x00,
                  0x00, 0x00, 0x00, 0x00]); // e_ident
    байты.extend(2u16.to_le_bytes()); // e_type
    байты.extend(62u16.to_le_bytes()); // e_machine
    байты.extend(1u32.to_le_bytes()); // e_version
    байты.extend((точка_входа + размер_заголовков + программа.данные.len() as u64).to_le_bytes()); // e_entry
    байты.extend(64u64.to_le_bytes()); // e_phoff
    байты.extend(0u64.to_le_bytes()); // e_shoff
    байты.extend(0u32.to_le_bytes()); // e_flags
    байты.extend(64u16.to_le_bytes()); // e_ehsize
    байты.extend(56u16.to_le_bytes()); // e_phentsize
    байты.extend(1u16.to_le_bytes()); // e_phnum
    байты.extend(64u16.to_le_bytes()); // e_shentsize
    байты.extend(0u16.to_le_bytes()); // e_shnum
    байты.extend(0u16.to_le_bytes()); // e_shstrndx

    байты.extend(1u32.to_le_bytes()); // p_type
    байты.extend(7u32.to_le_bytes()); // p_flags
    байты.extend(0u64.to_le_bytes()); // p_offset
    байты.extend(точка_входа.to_le_bytes()); // p_vaddr
    байты.extend(точка_входа.to_le_bytes()); // p_paddr
    байты.extend((размер_заголовков + код.len() as u64).to_le_bytes()); // p_filesz
    байты.extend((размер_заголовков + код.len() as u64).to_le_bytes()); // p_memsz
    байты.extend(4096u64.to_le_bytes()); // p_align

    байты.extend(&код);

    let mut файл = fs::File::create(путь_к_файлу).map_err(|ошибка| {
        eprintln!("ОШИБКА: не удалось открыть файл «путь_к_файлу»: {ошибка}");
    })?;

    #[cfg(all(unix))] {
        use std::os::unix::fs::PermissionsExt;
        let mut права = файл.metadata().map_err(|ошибка| {
            eprintln!("ОШИБКА: не получилось прочитать метаданные файла «{путь_к_файлу}»: {ошибка}",
                      путь_к_файлу = путь_к_файлу.display());
        })?.permissions();
        права.set_mode(0o755);
        файл.set_permissions(права).map_err(|ошибка| {
            eprintln!("ОШИБКА: не получилось установить права для файла «{путь_к_файлу}»: {ошибка}",
                      путь_к_файлу = путь_к_файлу.display());
        })?;
    }

    match файл.write(&байты) {
        Ok(_) => {
            println!("ИНФО: сгенерирован файл «{путь_к_файлу}»",
                     путь_к_файлу = путь_к_файлу.display());
            Ok(())
        }
        Err(ошибка) => {
            eprintln!("ОШИБКА: не удалось записать файл «{путь_к_файлу}»: {ошибка}",
                      путь_к_файлу = путь_к_файлу.display());
            Err(())
        }
    }
}
