use std::fs;
use std::env;
use std::io;
use std::process::ExitCode;
use std::collections::HashMap;
use std::num::{IntErrorKind};

#[path="./язык.rs"]
mod язык;
#[path="./лекс.rs"]
#[macro_use]
mod лекс;

use лекс::*;

#[derive(Debug)]
enum Тип {
    Цел
}

struct Переменная {
    имя: Лексема,
    тип: Тип,
}

fn разобрать_тип(лекс: &mut Лексер) -> Option<Тип> {
    let имя_типа = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    match имя_типа.текст.as_str() {
        "цел" => Some(Тип::Цел),
        _ => {
            диагностика!(&имя_типа.лок, "ОШИБКА",
                         "неизвестный тип «{имя_типа}»",
                         имя_типа = &имя_типа.текст);
            None
        }
    }
}

fn разобрать_переменную(лекс: &mut Лексер) -> Option<Переменная> {
    let имя = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    let тип = разобрать_тип(лекс)?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ТочкаЗапятая])?;
    Some(Переменная{имя, тип})
}

#[derive(Debug)]
enum Выражение {
    Число(usize),
    Строка(Лексема),
}

#[derive(Debug)]
enum Утверждение {
    Присваивание{имя: Лексема, значение: Выражение},
    Вызов{имя: Лексема, аргументы: Vec<Выражение>},
}

#[derive(Debug)]
struct Процедура {
    имя: Лексема,
    тело: Vec<Утверждение>
}

impl Процедура {
    fn новая(имя: Лексема) -> Процедура {
        Процедура {
            имя,
            тело: Vec::new(),
        }
    }
}

fn разобрать_выражение(лекс: &mut Лексер) -> Option<Выражение> {
    let лексема = лекс.ожидать_виды(&[
        ВидЛексемы::Число,
        ВидЛексемы::Строка
    ])?;
    match лексема.вид {
        ВидЛексемы::Число => {
            match лексема.текст.parse() {
                Ok(число) => Some(Выражение::Число(число)),
                Err(ошибка) => match ошибка.kind() {
                    IntErrorKind::PosOverflow => {
                        диагностика!(&лексема.лок, "ОШИБКА", "Число слишком большое");
                        None
                    }
                    IntErrorKind::Empty => unreachable!(),
                    IntErrorKind::InvalidDigit => unreachable!(),
                    IntErrorKind::NegOverflow => unreachable!(),
                    IntErrorKind::Zero => unreachable!(),
                    _ => {
                        диагностика!(&лексема.лок, "ОШИБКА", "Число некорректно");
                        None
                    }
                }
            }
        }
        ВидЛексемы::Строка => Some(Выражение::Строка(лексема)),
        _ => unreachable!(),
    }
}

fn разобрать_процедуру(лекс: &mut Лексер) -> Option<Процедура> {
    let имя = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ОткрытаяСкобка])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ЗакрытаяСкобка])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::КлючНч])?;
    let mut процедура = Процедура::новая(имя);

    loop {
        let лексема = лекс.ожидать_виды(&[
            ВидЛексемы::Идент,
            ВидЛексемы::КлючКц,
        ])?;
        match лексема.вид {
            ВидЛексемы::Идент => {
                let имя = лексема;
                let лексема = лекс.ожидать_виды(&[
                    ВидЛексемы::Присваивание,
                    ВидЛексемы::ОткрытаяСкобка
                ])?;
                match лексема.вид {
                    ВидЛексемы::Присваивание => {
                        let значение = разобрать_выражение(лекс)?;
                        let _ = лекс.ожидать_виды(&[ВидЛексемы::ТочкаЗапятая])?;
                        процедура.тело.push(Утверждение::Присваивание {
                            имя,
                            значение
                        });
                    }
                    ВидЛексемы::ОткрытаяСкобка => {
                        let аргумент = разобрать_выражение(лекс)?;
                        let _ = лекс.ожидать_виды(&[ВидЛексемы::ЗакрытаяСкобка])?;
                        let _ = лекс.ожидать_виды(&[ВидЛексемы::ТочкаЗапятая])?;
                        процедура.тело.push(Утверждение::Вызов {
                            имя,
                            аргументы: vec![аргумент],
                        });
                    }
                    _ => unreachable!()
                }
            }
            ВидЛексемы::КлючКц => break,
            _ => unreachable!(),
        }
    }
    Some(процедура)
}

#[derive(Default)]
struct Модуль {
    переменные: HashMap<String, Переменная>,
    процедуры: HashMap<String, Процедура>,
}

fn разобрать_модуль(лекс: &mut Лексер) -> Option<Модуль> {
    let mut модуль = Модуль::default();
    loop {
        let ключ = лекс.ожидать_виды(&[
            ВидЛексемы::КлючПер,
            ВидЛексемы::КлючПро,
            ВидЛексемы::Конец,
        ])?;
        match ключ.вид {
            ВидЛексемы::КлючПер => {
                let переменная = разобрать_переменную(лекс)?;
                if let Some(существующая_переменная) = модуль.переменные.get(&переменная.имя.текст) {
                    диагностика!(&переменная.имя.лок, "ОШИБКА",
                                 "переопределение переменной «{имя}»",
                                 имя = переменная.имя.текст);
                    диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                                 "предыдущее определение находится здесь");
                    return None
                }
                модуль.переменные.insert(переменная.имя.текст.clone(), переменная);
            }
            ВидЛексемы::КлючПро => {
                let процедура = разобрать_процедуру(лекс)?;
                // СДЕЛАТЬ: нужна ли проверка на коллизии между переменными и процедурами?
                if let Some(существующая_процедура) = модуль.процедуры.get(&процедура.имя.текст) {
                    диагностика!(&процедура.имя.лок, "ОШИБКА",
                                 "переопределение процедуры «{имя}»",
                                 имя = процедура.имя.текст);
                    диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                                 "предыдущее определение находится здесь");
                    return None
                }
                модуль.процедуры.insert(процедура.имя.текст.clone(), процедура);
            }
            ВидЛексемы::Конец => return Some(модуль),
            _ => unreachable!(),
        }
    }
}

fn main() -> ExitCode {
    let mut аргы = env::args();
    let программа = аргы.next().expect("программа");
    let путь_к_файлу = if let Some(путь_к_файлу) = аргы.next() {
        путь_к_файлу
    } else {
        eprintln!("Пример: {программа} <файл.хуя>");
        eprintln!("ОШИБКА: требуется файл с программой");
        return ExitCode::FAILURE;
    };
    let содержание: Vec<char> = match fs::read_to_string(&путь_к_файлу) {
        Ok(содержание) => содержание.chars().collect(),
        Err(ошибка) => {
            match ошибка.kind() {
                io::ErrorKind::NotFound => eprintln!("ОШИБКА: файл «{путь_к_файлу}» не найден"),
                _ => eprintln!("ОШИБКА: не получилось прочитать файл «{путь_к_файлу}»: {ошибка}"),
            }
            return ExitCode::FAILURE;
        }
    };
    let mut лекс = Лексер::новый(&путь_к_файлу, &содержание);

    if let Some(модуль) = разобрать_модуль(&mut лекс) {
        for (_, процедура) in модуль.процедуры {
            println!("{процедура:?}")
        }
    }

    ExitCode::SUCCESS
}
