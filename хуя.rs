use std::fs;
use std::env;
use std::io;
use std::process::ExitCode;
use std::collections::HashMap;

#[path="./язык.rs"]
mod язык;
#[path="./лекс.rs"]
#[macro_use]
mod лекс;

use лекс::*;

#[derive(Debug)]
enum Тип {
    Цел
}

struct Переменная {
    имя: Лексема,
    тип: Тип,
}

fn разобрать_тип(лекс: &mut Лексер) -> Option<Тип> {
    let имя_типа = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    match имя_типа.текст.as_str() {
        "цел" => Some(Тип::Цел),
        _ => {
            диагностика!(&имя_типа.лок, "ОШИБКА",
                         "неизвестный тип {имя_типа}",
                         имя_типа = &имя_типа.текст);
            None
        }
    }
}

fn разобрать_переменную(лекс: &mut Лексер) -> Option<Переменная> {
    let имя = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    let тип = разобрать_тип(лекс)?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ТочкаЗапятая])?;
    Some(Переменная{имя, тип})
}

struct Процедура {
    имя: Лексема
}

fn разобрать_процедуру(лекс: &mut Лексер) -> Option<Процедура> {
    let имя = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ОткрытаяСкобка])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ЗакрытаяСкобка])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::КлючНч])?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::КлючКц])?;
    Some(Процедура{имя})
}

#[derive(Default)]
struct Модуль {
    переменные: HashMap<String, Переменная>,
    процедуры: HashMap<String, Процедура>,
}

fn разобрать_модуль(лекс: &mut Лексер) -> Option<Модуль> {
    let mut модуль = Модуль::default();
    loop {
        let ключ = лекс.ожидать_виды(&[
            ВидЛексемы::КлючПер,
            ВидЛексемы::КлючПро,
            ВидЛексемы::Конец,
        ])?;
        match ключ.вид {
            ВидЛексемы::КлючПер => {
                let переменная = разобрать_переменную(лекс)?;
                if let Some(существующая_переменная) = модуль.переменные.get(&переменная.имя.текст) {
                    // СДЕЛАТЬ: использовать «ёлочки» во всех диагностиках.
                    диагностика!(&переменная.имя.лок, "ОШИБКА",
                                 "переопределение переменной «{имя}»",
                                 имя = переменная.имя.текст);
                    диагностика!(&существующая_переменная.имя.лок, "ИНФО",
                                 "предыдущее определение находится здесь");
                    return None
                }
                модуль.переменные.insert(переменная.имя.текст.clone(), переменная);
            }
            ВидЛексемы::КлючПро => {
                let процедура = разобрать_процедуру(лекс)?;
                // СДЕЛАТЬ: нужна ли проверку на коллизии между переменными и процедурами?
                if let Some(существующая_процедура) = модуль.процедуры.get(&процедура.имя.текст) {
                    диагностика!(&процедура.имя.лок, "ОШИБКА",
                                 "переопределение процедуры «{имя}»",
                                 имя = процедура.имя.текст);
                    диагностика!(&существующая_процедура.имя.лок, "ИНФО",
                                 "предыдущее определение находится здесь");
                    return None
                }
                модуль.процедуры.insert(процедура.имя.текст.clone(), процедура);
            }
            ВидЛексемы::Конец => return Some(модуль),
            _ => unreachable!(),
        }
    }
}

fn main() -> ExitCode {
    let mut аргы = env::args();
    let программа = аргы.next().expect("программа");
    let путь_к_файлу = if let Some(путь_к_файлу) = аргы.next() {
        путь_к_файлу
    } else {
        eprintln!("Пример: {программа} <файл.хуя>");
        eprintln!("ОШИБКА: требуется файл с программой");
        return ExitCode::FAILURE;
    };
    let содержание: Vec<char> = match fs::read_to_string(&путь_к_файлу) {
        Ok(содержание) => содержание.chars().collect(),
        Err(ошибка) => {
            match ошибка.kind() {
                io::ErrorKind::NotFound => eprintln!("ОШИБКА: файл «{путь_к_файлу}» не найден"),
                _ => eprintln!("ОШИБКА: не получилось прочитать файл «{путь_к_файлу}»: {ошибка}"),
            }
            return ExitCode::FAILURE;
        }
    };
    let mut лекс = Лексер::новый(&путь_к_файлу, &содержание);

    if let Some(модуль) = разобрать_модуль(&mut лекс) {
        println!("Модуль «{путь_к_файлу}» содержит:");
        println!("    Процедур:   {процедуры}", процедуры = модуль.процедуры.len());
        println!("    Переменных: {переменные}", переменные = модуль.переменные.len());
    }

    ExitCode::SUCCESS
}
