use std::fs;
use std::env;
use std::io;
use std::process::ExitCode;

#[path="./язык.rs"]
mod язык;
#[path="./лекс.rs"]
#[macro_use]
mod лекс;

use лекс::*;

#[derive(Debug)]
enum Тип {
    Цел
}

struct Переменная {
    имя: Лексема,
    тип: Тип,
}

fn разобрать_тип(лекс: &mut Лексер) -> Option<Тип> {
    let имя_типа = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    match имя_типа.текст.as_str() {
        "цел" => Some(Тип::Цел),
        _ => {
            диагностика!(&имя_типа.лок, "ОШИБКА",
                         "неизвестный тип {имя_типа}",
                         имя_типа = &имя_типа.текст);
            None
        }
    }
}

fn разобрать_переменную(лекс: &mut Лексер) -> Option<Переменная> {
    let _ = лекс.ожидать_виды(&[ВидЛексемы::КлючПер])?;
    let имя = лекс.ожидать_виды(&[ВидЛексемы::Идент])?;
    let тип = разобрать_тип(лекс)?;
    let _ = лекс.ожидать_виды(&[ВидЛексемы::ТочкаЗапятая])?;
    Some(Переменная{имя, тип})
}

fn main() -> ExitCode {
    let mut аргы = env::args();
    let программа = аргы.next().expect("программа");
    let путь_к_файлу = if let Some(путь_к_файлу) = аргы.next() {
        путь_к_файлу
    } else {
        eprintln!("Пример: {программа} <файл.хуя>");
        eprintln!("ОШИБКА: требуется файл с программой");
        return ExitCode::FAILURE;
    };
    let содержание: Vec<char> = match fs::read_to_string(&путь_к_файлу) {
        Ok(содержание) => содержание.chars().collect(),
        Err(ошибка) => {
            match ошибка.kind() {
                io::ErrorKind::NotFound => eprintln!("ОШИБКА: файл {путь_к_файлу} не найден"),
                _ => eprintln!("ОШИБКА: не получилось прочитать файл {путь_к_файлу}: {ошибка}"),
            }
            return ExitCode::FAILURE;
        }
    };
    let mut лекс = Лексер::новый(&путь_к_файлу, &содержание);

    if let Some(пер) = разобрать_переменную(&mut лекс) {
        диагностика!(&пер.имя.лок, "ИНФО", "определена переменная {имя} типа {тип:?}",
                     имя = пер.имя.текст,
                     тип = пер.тип);
    }

    ExitCode::SUCCESS
}
